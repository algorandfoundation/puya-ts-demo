#pragma version 10
#pragma typetrack false

// contracts/lsig-with-app/lsig-with-app.algo.ts::program() -> uint64:
main:
    intcblock TMPL_APP_ID
    // contracts/lsig-with-app/lsig-with-app.algo.ts:30-40
    // assertMatch(Txn, {
    //   assetAmount: 0,
    //   assetReceiver: Txn.sender,
    //   // It's very important to set fee to 0 for delegated logic signatures
    //   // Otherwise the fee can be used to drain the signer's account
    //   fee: 0,
    //   // Also very important to check that the rekey is set to zero address
    //   rekeyTo: Global.zeroAddress,
    //   // Finally we must ensure that this is not a close transaction, which will drain the signer's account of the given asset
    //   assetCloseTo: Global.zeroAddress,
    // });
    txn AssetAmount
    !
    txn AssetReceiver
    // contracts/lsig-with-app/lsig-with-app.algo.ts:32
    // assetReceiver: Txn.sender,
    txn Sender
    // contracts/lsig-with-app/lsig-with-app.algo.ts:30-40
    // assertMatch(Txn, {
    //   assetAmount: 0,
    //   assetReceiver: Txn.sender,
    //   // It's very important to set fee to 0 for delegated logic signatures
    //   // Otherwise the fee can be used to drain the signer's account
    //   fee: 0,
    //   // Also very important to check that the rekey is set to zero address
    //   rekeyTo: Global.zeroAddress,
    //   // Finally we must ensure that this is not a close transaction, which will drain the signer's account of the given asset
    //   assetCloseTo: Global.zeroAddress,
    // });
    ==
    &&
    txn Fee
    !
    &&
    txn RekeyTo
    // contracts/lsig-with-app/lsig-with-app.algo.ts:37
    // rekeyTo: Global.zeroAddress,
    global ZeroAddress
    // contracts/lsig-with-app/lsig-with-app.algo.ts:30-40
    // assertMatch(Txn, {
    //   assetAmount: 0,
    //   assetReceiver: Txn.sender,
    //   // It's very important to set fee to 0 for delegated logic signatures
    //   // Otherwise the fee can be used to drain the signer's account
    //   fee: 0,
    //   // Also very important to check that the rekey is set to zero address
    //   rekeyTo: Global.zeroAddress,
    //   // Finally we must ensure that this is not a close transaction, which will drain the signer's account of the given asset
    //   assetCloseTo: Global.zeroAddress,
    // });
    ==
    &&
    txn AssetCloseTo
    // contracts/lsig-with-app/lsig-with-app.algo.ts:39
    // assetCloseTo: Global.zeroAddress,
    global ZeroAddress
    // contracts/lsig-with-app/lsig-with-app.algo.ts:30-40
    // assertMatch(Txn, {
    //   assetAmount: 0,
    //   assetReceiver: Txn.sender,
    //   // It's very important to set fee to 0 for delegated logic signatures
    //   // Otherwise the fee can be used to drain the signer's account
    //   fee: 0,
    //   // Also very important to check that the rekey is set to zero address
    //   rekeyTo: Global.zeroAddress,
    //   // Finally we must ensure that this is not a close transaction, which will drain the signer's account of the given asset
    //   assetCloseTo: Global.zeroAddress,
    // });
    ==
    &&
    assert // assert target is match for conditions
    // contracts/lsig-with-app/lsig-with-app.algo.ts:42
    // const appCall = gtxn.ApplicationCallTxn(Txn.groupIndex + 1);
    txn GroupIndex
    pushint 1 // 1
    +
    dup
    gtxns TypeEnum
    pushint 6 // appl
    ==
    assert // transaction type is appl
    // contracts/lsig-with-app/lsig-with-app.algo.ts:44
    // assert(appCall.appId === TemplateVar<Application>("APP_ID"));
    dup
    gtxns ApplicationID
    intc_0 // TMPL_APP_ID
    ==
    assert
    // contracts/lsig-with-app/lsig-with-app.algo.ts:45
    // assert(appCall.appArgs(0) === methodSelector("verifyCreator(axfer)void"));
    pushint 0 // 0
    gtxnsas ApplicationArgs
    pushbytes 0x8d5aa727 // method "verifyCreator(axfer)void"
    ==
    // contracts/lsig-with-app/lsig-with-app.algo.ts:46
    // return true;
    return

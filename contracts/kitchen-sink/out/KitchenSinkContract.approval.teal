#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 1 0
    bytecblock "b" 0xff "globalInt" "customKey"
    txn ApplicationID
    bnz main_after_if_else@2
    // contracts/kitchen-sink/kitchen-sink.algo.ts:27
    // globalInt = GlobalState({ initialValue: Uint64(4) });
    bytec_2 // "globalInt"
    pushint 4 // 4
    app_global_put

main_after_if_else@2:
    // contracts/kitchen-sink/kitchen-sink.algo.ts:26
    // export class KitchenSinkContract extends Contract {
    pushbytes 0x29314d95 // method "optIn()void"
    txna ApplicationArgs 0
    match main_optIn_route@4
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@14
    pushbytess 0x2dac715d 0xf743ce21 0x3a49b2a3 0xf5d898b7 0x6ce0f4b5 0x49a55ae8 // method "useState(uint64,string,uint64)void", method "addToBox(uint64)void", method "addToBoxMap(string)void", method "insertIntoBoxRef(byte[],uint64,uint64)void", method "sayHello(string,uint64)string", method "checkTransaction(pay)void"
    txna ApplicationArgs 0
    match useState addToBox addToBoxMap insertIntoBoxRef sayHello checkTransaction
    err

main_create_NoOp@14:
    // contracts/kitchen-sink/kitchen-sink.algo.ts:26
    // export class KitchenSinkContract extends Contract {
    pushbytes 0xcc0c6e4d // method "createApp()void"
    txna ApplicationArgs 0
    match createApp
    err

main_optIn_route@4:
    // contracts/kitchen-sink/kitchen-sink.algo.ts:53
    // @abimethod({ allowActions: ["OptIn"] })
    txn OnCompletion
    intc_0 // OptIn
    ==
    txn ApplicationID
    &&
    return // on error: OnCompletion must be OptIn && can only call when not creating


// contracts/kitchen-sink/kitchen-sink.algo.ts::KitchenSinkContract.useState[routing]() -> void:
useState:
    // contracts/kitchen-sink/kitchen-sink.algo.ts:36
    // useState(a: uint64, b: string, c: uint64) {
    txna ApplicationArgs 1
    btoi
    dup
    txna ApplicationArgs 2
    extract 2 0
    swap
    txna ApplicationArgs 3
    btoi
    cover 2
    // contracts/kitchen-sink/kitchen-sink.algo.ts:37
    // this.globalInt.value *= a;
    intc_1 // 0
    // contracts/kitchen-sink/kitchen-sink.algo.ts:27
    // globalInt = GlobalState({ initialValue: Uint64(4) });
    bytec_2 // "globalInt"
    // contracts/kitchen-sink/kitchen-sink.algo.ts:37
    // this.globalInt.value *= a;
    app_global_get_ex
    assert // check GlobalState exists
    *
    // contracts/kitchen-sink/kitchen-sink.algo.ts:27
    // globalInt = GlobalState({ initialValue: Uint64(4) });
    bytec_2 // "globalInt"
    // contracts/kitchen-sink/kitchen-sink.algo.ts:37
    // this.globalInt.value *= a;
    swap
    app_global_put
    // contracts/kitchen-sink/kitchen-sink.algo.ts:38
    // if (this.globalString.hasValue) {
    intc_1 // 0
    // contracts/kitchen-sink/kitchen-sink.algo.ts:28
    // globalString = GlobalState<string>({ key: "customKey" });
    bytec_3 // "customKey"
    // contracts/kitchen-sink/kitchen-sink.algo.ts:38
    // if (this.globalString.hasValue) {
    app_global_get_ex
    bury 1
    bz useState_else_body@3
    // contracts/kitchen-sink/kitchen-sink.algo.ts:39
    // this.globalString.value += b;
    intc_1 // 0
    // contracts/kitchen-sink/kitchen-sink.algo.ts:28
    // globalString = GlobalState<string>({ key: "customKey" });
    bytec_3 // "customKey"
    // contracts/kitchen-sink/kitchen-sink.algo.ts:39
    // this.globalString.value += b;
    app_global_get_ex
    assert // check GlobalState exists
    swap
    concat
    // contracts/kitchen-sink/kitchen-sink.algo.ts:28
    // globalString = GlobalState<string>({ key: "customKey" });
    bytec_3 // "customKey"
    // contracts/kitchen-sink/kitchen-sink.algo.ts:39
    // this.globalString.value += b;
    swap
    app_global_put

useState_after_if_else@4:
    // contracts/kitchen-sink/kitchen-sink.algo.ts:43
    // if (Txn.sender.isOptedIn(Global.currentApplicationId)) {
    txn Sender
    global CurrentApplicationID
    app_opted_in
    bz useState_after_if_else@6
    // contracts/kitchen-sink/kitchen-sink.algo.ts:44
    // this.localBigInt(Txn.sender).value = BigUint(c) * BigUint(a);
    dup
    itob
    dig 2
    itob
    b*
    txn Sender
    // contracts/kitchen-sink/kitchen-sink.algo.ts:30
    // localBigInt = LocalState<biguint>();
    pushbytes "localBigInt"
    // contracts/kitchen-sink/kitchen-sink.algo.ts:44
    // this.localBigInt(Txn.sender).value = BigUint(c) * BigUint(a);
    uncover 2
    app_local_put

useState_after_if_else@6:
    // contracts/kitchen-sink/kitchen-sink.algo.ts:36
    // useState(a: uint64, b: string, c: uint64) {
    intc_0 // 1
    return

useState_else_body@3:
    // contracts/kitchen-sink/kitchen-sink.algo.ts:28
    // globalString = GlobalState<string>({ key: "customKey" });
    bytec_3 // "customKey"
    // contracts/kitchen-sink/kitchen-sink.algo.ts:41
    // this.globalString.value = b;
    swap
    app_global_put
    b useState_after_if_else@4


// contracts/kitchen-sink/kitchen-sink.algo.ts::KitchenSinkContract.createApp[routing]() -> void:
createApp:
    // contracts/kitchen-sink/kitchen-sink.algo.ts:27
    // globalInt = GlobalState({ initialValue: Uint64(4) });
    bytec_2 // "globalInt"
    // contracts/kitchen-sink/kitchen-sink.algo.ts:50
    // this.globalInt.value = Global.currentApplicationId.id;
    global CurrentApplicationID
    app_global_put
    // contracts/kitchen-sink/kitchen-sink.algo.ts:48
    // @abimethod({ onCreate: "require", allowActions: "NoOp" })
    intc_0 // 1
    return


// contracts/kitchen-sink/kitchen-sink.algo.ts::KitchenSinkContract.addToBox[routing]() -> void:
addToBox:
    // contracts/kitchen-sink/kitchen-sink.algo.ts:56
    // addToBox(x: uint64) {
    txna ApplicationArgs 1
    // contracts/kitchen-sink/kitchen-sink.algo.ts:32
    // boxOfArray = Box<DynamicArray<Uint<64>>>({ key: "b" });
    bytec_0 // "b"
    // contracts/kitchen-sink/kitchen-sink.algo.ts:57
    // if (!this.boxOfArray.exists) {
    box_len
    bury 1
    bnz addToBox_else_body@3
    // contracts/kitchen-sink/kitchen-sink.algo.ts:58
    // this.boxOfArray.value = new DynamicArray(new Uint<64>(x));
    pushbytes 0x0001
    swap
    concat
    // contracts/kitchen-sink/kitchen-sink.algo.ts:32
    // boxOfArray = Box<DynamicArray<Uint<64>>>({ key: "b" });
    bytec_0 // "b"
    // contracts/kitchen-sink/kitchen-sink.algo.ts:58
    // this.boxOfArray.value = new DynamicArray(new Uint<64>(x));
    box_del
    pop
    // contracts/kitchen-sink/kitchen-sink.algo.ts:32
    // boxOfArray = Box<DynamicArray<Uint<64>>>({ key: "b" });
    bytec_0 // "b"
    // contracts/kitchen-sink/kitchen-sink.algo.ts:58
    // this.boxOfArray.value = new DynamicArray(new Uint<64>(x));
    swap
    box_put

addToBox_after_if_else@4:
    // contracts/kitchen-sink/kitchen-sink.algo.ts:56
    // addToBox(x: uint64) {
    intc_0 // 1
    return

addToBox_else_body@3:
    // contracts/kitchen-sink/kitchen-sink.algo.ts:32
    // boxOfArray = Box<DynamicArray<Uint<64>>>({ key: "b" });
    bytec_0 // "b"
    // contracts/kitchen-sink/kitchen-sink.algo.ts:60
    // this.boxOfArray.value.push(new Uint<64>(x));
    box_get
    assert // Box must have value
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_1 // 0
    extract_uint16
    intc_0 // 1
    +
    itob
    extract 6 2
    replace2 0
    // contracts/kitchen-sink/kitchen-sink.algo.ts:32
    // boxOfArray = Box<DynamicArray<Uint<64>>>({ key: "b" });
    bytec_0 // "b"
    // contracts/kitchen-sink/kitchen-sink.algo.ts:60
    // this.boxOfArray.value.push(new Uint<64>(x));
    box_del
    pop
    // contracts/kitchen-sink/kitchen-sink.algo.ts:32
    // boxOfArray = Box<DynamicArray<Uint<64>>>({ key: "b" });
    bytec_0 // "b"
    // contracts/kitchen-sink/kitchen-sink.algo.ts:60
    // this.boxOfArray.value.push(new Uint<64>(x));
    swap
    box_put
    b addToBox_after_if_else@4


// contracts/kitchen-sink/kitchen-sink.algo.ts::KitchenSinkContract.addToBoxMap[routing]() -> void:
addToBoxMap:
    // contracts/kitchen-sink/kitchen-sink.algo.ts:64
    // addToBoxMap(x: string) {
    txna ApplicationArgs 1
    extract 2 0
    // contracts/kitchen-sink/kitchen-sink.algo.ts:65
    // this.boxMap(Txn.sender).value = Bytes(x);
    txn Sender
    dup
    box_del
    pop
    swap
    box_put
    // contracts/kitchen-sink/kitchen-sink.algo.ts:64
    // addToBoxMap(x: string) {
    intc_0 // 1
    return


// contracts/kitchen-sink/kitchen-sink.algo.ts::KitchenSinkContract.insertIntoBoxRef[routing]() -> void:
insertIntoBoxRef:
    // contracts/kitchen-sink/kitchen-sink.algo.ts:68
    // insertIntoBoxRef(content: bytes, offset: uint64, boxSize: uint64) {
    txna ApplicationArgs 1
    extract 2 0
    dup
    txna ApplicationArgs 2
    btoi
    dup
    cover 2
    txna ApplicationArgs 3
    btoi
    dup
    cover 2
    cover 3
    // contracts/kitchen-sink/kitchen-sink.algo.ts:69
    // assert(offset + content.length < boxSize);
    uncover 2
    len
    +
    dup
    uncover 2
    <
    assert
    // contracts/kitchen-sink/kitchen-sink.algo.ts:34
    // boxRef = Box<bytes>({ key: Bytes.fromHex("FF") });
    bytec_1 // 0xff
    // contracts/kitchen-sink/kitchen-sink.algo.ts:70
    // if (this.boxRef.exists) {
    box_len
    bury 1
    bz insertIntoBoxRef_else_body@3
    // contracts/kitchen-sink/kitchen-sink.algo.ts:34
    // boxRef = Box<bytes>({ key: Bytes.fromHex("FF") });
    bytec_1 // 0xff
    // contracts/kitchen-sink/kitchen-sink.algo.ts:71
    // this.boxRef.create({ size: boxSize });
    dig 2
    box_create
    pop

insertIntoBoxRef_after_if_else@6:
    // contracts/kitchen-sink/kitchen-sink.algo.ts:34
    // boxRef = Box<bytes>({ key: Bytes.fromHex("FF") });
    bytec_1 // 0xff
    // contracts/kitchen-sink/kitchen-sink.algo.ts:75
    // this.boxRef.splice(offset, offset + content.length, content);
    dig 3
    dig 2
    dig 6
    box_splice
    // contracts/kitchen-sink/kitchen-sink.algo.ts:68
    // insertIntoBoxRef(content: bytes, offset: uint64, boxSize: uint64) {
    intc_0 // 1
    return

insertIntoBoxRef_else_body@3:
    // contracts/kitchen-sink/kitchen-sink.algo.ts:34
    // boxRef = Box<bytes>({ key: Bytes.fromHex("FF") });
    bytec_1 // 0xff
    // contracts/kitchen-sink/kitchen-sink.algo.ts:72
    // } else if (this.boxRef.length !== boxSize) {
    box_len
    assert // Box must have value
    dig 2
    !=
    bz insertIntoBoxRef_after_if_else@6
    // contracts/kitchen-sink/kitchen-sink.algo.ts:34
    // boxRef = Box<bytes>({ key: Bytes.fromHex("FF") });
    bytec_1 // 0xff
    // contracts/kitchen-sink/kitchen-sink.algo.ts:73
    // this.boxRef.resize(boxSize);
    dig 2
    box_resize
    b insertIntoBoxRef_after_if_else@6


// contracts/kitchen-sink/kitchen-sink.algo.ts::KitchenSinkContract.sayHello[routing]() -> void:
sayHello:
    // contracts/kitchen-sink/kitchen-sink.algo.ts:78
    // sayHello(name: string, a: uint64): string {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    // contracts/kitchen-sink/kitchen-sink.algo.ts:79
    // return `${this.getHello()} ${name} ${Bytes(a)}`;
    pushbytes "Hello "
    uncover 2
    concat
    pushbytes " "
    concat
    swap
    itob
    concat
    // contracts/kitchen-sink/kitchen-sink.algo.ts:78
    // sayHello(name: string, a: uint64): string {
    dup
    len
    itob
    extract 6 2
    swap
    concat
    pushbytes 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// contracts/kitchen-sink/kitchen-sink.algo.ts::KitchenSinkContract.checkTransaction[routing]() -> void:
checkTransaction:
    // contracts/kitchen-sink/kitchen-sink.algo.ts:82
    // checkTransaction(pay: gtxn.PaymentTxn) {
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // contracts/kitchen-sink/kitchen-sink.algo.ts:83-88
    // assertMatch(pay, {
    //   amount: { between: [1000, 2000] },
    //   lastValid: { greaterThan: Global.round },
    //   sender: Txn.sender,
    //   receiver: Global.currentApplicationId.address,
    // });
    dup
    gtxns Amount
    dup
    // contracts/kitchen-sink/kitchen-sink.algo.ts:84
    // amount: { between: [1000, 2000] },
    pushint 2000 // 2000
    // contracts/kitchen-sink/kitchen-sink.algo.ts:83-88
    // assertMatch(pay, {
    //   amount: { between: [1000, 2000] },
    //   lastValid: { greaterThan: Global.round },
    //   sender: Txn.sender,
    //   receiver: Global.currentApplicationId.address,
    // });
    <=
    swap
    // contracts/kitchen-sink/kitchen-sink.algo.ts:84
    // amount: { between: [1000, 2000] },
    pushint 1000 // 1000
    // contracts/kitchen-sink/kitchen-sink.algo.ts:83-88
    // assertMatch(pay, {
    //   amount: { between: [1000, 2000] },
    //   lastValid: { greaterThan: Global.round },
    //   sender: Txn.sender,
    //   receiver: Global.currentApplicationId.address,
    // });
    >=
    &&
    dig 1
    gtxns LastValid
    // contracts/kitchen-sink/kitchen-sink.algo.ts:85
    // lastValid: { greaterThan: Global.round },
    global Round
    // contracts/kitchen-sink/kitchen-sink.algo.ts:83-88
    // assertMatch(pay, {
    //   amount: { between: [1000, 2000] },
    //   lastValid: { greaterThan: Global.round },
    //   sender: Txn.sender,
    //   receiver: Global.currentApplicationId.address,
    // });
    >
    &&
    dig 1
    gtxns Sender
    // contracts/kitchen-sink/kitchen-sink.algo.ts:86
    // sender: Txn.sender,
    txn Sender
    // contracts/kitchen-sink/kitchen-sink.algo.ts:83-88
    // assertMatch(pay, {
    //   amount: { between: [1000, 2000] },
    //   lastValid: { greaterThan: Global.round },
    //   sender: Txn.sender,
    //   receiver: Global.currentApplicationId.address,
    // });
    ==
    &&
    swap
    gtxns Receiver
    // contracts/kitchen-sink/kitchen-sink.algo.ts:87
    // receiver: Global.currentApplicationId.address,
    global CurrentApplicationID
    app_params_get AppAddress
    assert // application exists
    // contracts/kitchen-sink/kitchen-sink.algo.ts:83-88
    // assertMatch(pay, {
    //   amount: { between: [1000, 2000] },
    //   lastValid: { greaterThan: Global.round },
    //   sender: Txn.sender,
    //   receiver: Global.currentApplicationId.address,
    // });
    ==
    &&
    // contracts/kitchen-sink/kitchen-sink.algo.ts:82
    // checkTransaction(pay: gtxn.PaymentTxn) {
    return // on error: assert target is match for conditions

#pragma version 10
intcblock 1 8
bytecblock 0x62 0x4646 0x676c6f62616c496e74 0x637573746f6d4b6579

// This TEAL was generated by TEALScript v0.105.5
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
pushint 6
*
txn OnCompletion
+
switch *call_NoOp *call_OptIn *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// useState(uint64,string,uint64)void
*abi_route_useState:
	// c: uint64
	txna ApplicationArgs 3
	btoi

	// b: string
	txna ApplicationArgs 2
	extract 2 0

	// a: uint64
	txna ApplicationArgs 1
	btoi

	// execute useState(uint64,string,uint64)void
	callsub useState
	intc 0 // 1
	return

// useState(a: uint64, b: string, c: uint64): void
useState:
	proto 3 0

	// contracts/kitchen-sink/kitchen-sink.algo.ts:14
	// this.globalInt.value *= a
	bytec 2 //  "globalInt"
	app_global_get
	frame_dig -1 // a: uint64
	*
	bytec 2 //  "globalInt"
	swap
	app_global_put

	// *if0_condition
	// contracts/kitchen-sink/kitchen-sink.algo.ts:15
	// this.globalString.exists
	txna Applications 0
	bytec 3 //  "customKey"
	app_global_get_ex
	swap
	pop
	bz *if0_else

	// *if0_consequent
	// contracts/kitchen-sink/kitchen-sink.algo.ts:16
	// this.globalString.value += b
	bytec 3 //  "customKey"
	app_global_get
	extract 2 0
	frame_dig -2 // b: string
	concat
	bytec 3 //  "customKey"
	swap
	dup
	len
	itob
	extract 6 2
	swap
	concat
	app_global_put
	b *if0_end

*if0_else:
	// contracts/kitchen-sink/kitchen-sink.algo.ts:18
	// this.globalString.value = b
	bytec 3 //  "customKey"
	frame_dig -2 // b: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	app_global_put

*if0_end:
	// *if1_condition
	// contracts/kitchen-sink/kitchen-sink.algo.ts:20
	// this.txn.sender.isOptedInToApp(this.app.id)
	txn Sender
	txna Applications 0
	app_opted_in
	bz *if1_end

	// *if1_consequent
	// contracts/kitchen-sink/kitchen-sink.algo.ts:21
	// this.localBigInt(this.txn.sender).value = <uint<512>>(c * a)
	txn Sender
	pushbytes 0x6c6f63616c426967496e74 // "localBigInt"
	frame_dig -3 // c: uint64
	frame_dig -1 // a: uint64
	*
	itob
	dup
	bitlen
	pushint 512
	<=

	// <uint<512>>(c * a) overflowed 512 bits
	assert
	pushbytes 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	pushint 64
	-
	swap
	substring3
	app_local_put

*if1_end:
	retsub

// createApplication()void
*abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	intc 0 // 1
	return

// createApplication(): void
createApplication:
	proto 0 0

	// contracts/kitchen-sink/kitchen-sink.algo.ts:26
	// this.globalInt.value = 4
	bytec 2 //  "globalInt"
	pushint 4
	app_global_put

	// contracts/kitchen-sink/kitchen-sink.algo.ts:27
	// this.globalInt.value = this.app.id
	bytec 2 //  "globalInt"
	txna Applications 0
	app_global_put
	retsub

// optInToApplication()void
*abi_route_optInToApplication:
	// execute optInToApplication()void
	callsub optInToApplication
	intc 0 // 1
	return

// optInToApplication(): void
optInToApplication:
	proto 0 0
	retsub

// addToBox(uint64)void
*abi_route_addToBox:
	// x: uint64
	txna ApplicationArgs 1
	btoi

	// execute addToBox(uint64)void
	callsub addToBox
	intc 0 // 1
	return

// addToBox(x: uint64): void
addToBox:
	proto 1 0

	// *if2_condition
	// contracts/kitchen-sink/kitchen-sink.algo.ts:33
	// !this.boxOfArray.exists
	bytec 0 //  "b"
	box_len
	swap
	pop
	!
	bz *if2_else

	// *if2_consequent
	// contracts/kitchen-sink/kitchen-sink.algo.ts:34
	// this.boxOfArray.value = [x]
	bytec 0 //  "b"
	dup
	box_del
	pop
	frame_dig -1 // x: uint64
	itob
	dup
	len
	intc 1 // 8
	/
	itob
	extract 6 2
	swap
	concat
	box_put
	b *if2_end

*if2_else:
	// contracts/kitchen-sink/kitchen-sink.algo.ts:36
	// this.boxOfArray.value.push(x)
	bytec 0 //  "b"
	box_get

	// box value does not exist: this.boxOfArray.value
	assert
	extract 2 0
	frame_dig -1 // x: uint64
	itob
	concat
	bytec 0 //  "b"
	dup
	box_del
	pop
	swap
	dup
	len
	intc 1 // 8
	/
	itob
	extract 6 2
	swap
	concat
	box_put

*if2_end:
	retsub

// addToBoxMap(string)void
*abi_route_addToBoxMap:
	// x: string
	txna ApplicationArgs 1
	extract 2 0

	// execute addToBoxMap(string)void
	callsub addToBoxMap
	intc 0 // 1
	return

// addToBoxMap(x: string): void
addToBoxMap:
	proto 1 0

	// contracts/kitchen-sink/kitchen-sink.algo.ts:41
	// this.boxMap(this.txn.sender).value = x
	txn Sender
	dup
	box_del
	pop
	frame_dig -1 // x: string
	box_put
	retsub

// insertIntoBoxRef(byte[],uint64,uint64)void
*abi_route_insertIntoBoxRef:
	// boxSize: uint64
	txna ApplicationArgs 3
	btoi

	// offset: uint64
	txna ApplicationArgs 2
	btoi

	// content: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// execute insertIntoBoxRef(byte[],uint64,uint64)void
	callsub insertIntoBoxRef
	intc 0 // 1
	return

// insertIntoBoxRef(content: bytes, offset: uint64, boxSize: uint64): void
insertIntoBoxRef:
	proto 3 0

	// contracts/kitchen-sink/kitchen-sink.algo.ts:45
	// assert(offset + content.length < boxSize)
	frame_dig -2 // offset: uint64
	frame_dig -1 // content: bytes
	len
	+
	frame_dig -3 // boxSize: uint64
	<
	assert

	// *if3_condition
	// contracts/kitchen-sink/kitchen-sink.algo.ts:46
	// this.boxRef.exists
	bytec 1 //  "FF"
	box_len
	swap
	pop
	bz *if3_elseif1_condition

	// *if3_consequent
	// contracts/kitchen-sink/kitchen-sink.algo.ts:47
	// this.boxRef.create(boxSize)
	bytec 1 //  "FF"
	frame_dig -3 // boxSize: uint64
	box_create
	pop
	b *if3_end

*if3_elseif1_condition:
	// contracts/kitchen-sink/kitchen-sink.algo.ts:48
	// this.boxRef.size !== boxSize
	bytec 1 //  "FF"
	box_len

	// box value does not exist: this.boxRef.size
	assert
	frame_dig -3 // boxSize: uint64
	!=
	bz *if3_end

	// *if3_elseif1_consequent
	// contracts/kitchen-sink/kitchen-sink.algo.ts:49
	// this.boxRef.resize(boxSize)
	bytec 1 //  "FF"
	frame_dig -3 // boxSize: uint64
	box_resize

*if3_end:
	// contracts/kitchen-sink/kitchen-sink.algo.ts:51
	// this.boxRef.splice(offset, offset + content.length, content)
	bytec 1 //  "FF"
	frame_dig -2 // offset: uint64
	frame_dig -2 // offset: uint64
	frame_dig -1 // content: bytes
	len
	+
	frame_dig -1 // content: bytes
	box_splice
	retsub

// sayHello(string,uint64)string
*abi_route_sayHello:
	// The ABI return prefix
	pushbytes 0x151f7c75

	// a: uint64
	txna ApplicationArgs 2
	btoi

	// name: string
	txna ApplicationArgs 1
	extract 2 0

	// execute sayHello(string,uint64)string
	callsub sayHello
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 0 // 1
	return

// sayHello(name: string, a: uint64): string
sayHello:
	proto 2 1

	// contracts/kitchen-sink/kitchen-sink.algo.ts:55
	// return this.getHello() + name + itob(a);
	callsub getHello
	frame_dig -1 // name: string
	concat
	frame_dig -2 // a: uint64
	itob
	concat
	retsub

// checkTransaction(pay)void
*abi_route_checkTransaction:
	// pay: pay
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	intc 0 //  pay
	==

	// argument 0 (pay) for checkTransaction must be a pay transaction
	assert

	// execute checkTransaction(pay)void
	callsub checkTransaction
	intc 0 // 1
	return

// checkTransaction(pay: PayTxn): void
checkTransaction:
	proto 1 0

	// contracts/kitchen-sink/kitchen-sink.algo.ts:59
	// verifyPayTxn(pay, {
	//       amount: { greaterThan: 1000, lessThan: 2000 },
	//       lastValid: { greaterThan: globals.round },
	//       sender: this.txn.sender,
	//       receiver: this.app.address,
	//     })
	// verify amount
	frame_dig -1 // pay: PayTxn
	gtxns Amount
	pushint 1000
	>

	// transaction verification failed: {"txn":"pay","field":"amount","condition":"greaterThan","expected":">1000"}
	assert
	frame_dig -1 // pay: PayTxn
	gtxns Amount
	pushint 2000
	<

	// transaction verification failed: {"txn":"pay","field":"amount","condition":"lessThan","expected":"<2000"}
	assert

	// verify lastValid
	frame_dig -1 // pay: PayTxn
	gtxns LastValid
	global Round
	>

	// transaction verification failed: {"txn":"pay","field":"lastValid","condition":"greaterThan","expected":">globals.round"}
	assert

	// verify sender
	frame_dig -1 // pay: PayTxn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"pay","field":"sender","expected":"this.txn.sender"}
	assert

	// verify receiver
	frame_dig -1 // pay: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"pay","field":"receiver","expected":"this.app.address"}
	assert
	retsub

// getHello(): string
getHello:
	proto 0 1

	// contracts/kitchen-sink/kitchen-sink.algo.ts:68
	// return "Hello";
	pushbytes 0x48656c6c6f // "Hello"
	retsub

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x2dac715d // method "useState(uint64,string,uint64)void"
	pushbytes 0xf743ce21 // method "addToBox(uint64)void"
	pushbytes 0x3a49b2a3 // method "addToBoxMap(string)void"
	pushbytes 0xf5d898b7 // method "insertIntoBoxRef(byte[],uint64,uint64)void"
	pushbytes 0x6ce0f4b5 // method "sayHello(string,uint64)string"
	pushbytes 0x49a55ae8 // method "checkTransaction(pay)void"
	txna ApplicationArgs 0
	match *abi_route_useState *abi_route_addToBox *abi_route_addToBoxMap *abi_route_insertIntoBoxRef *abi_route_sayHello *abi_route_checkTransaction

	// this contract does not implement the given ABI method for call NoOp
	err

*call_OptIn:
	pushbytes 0x01a3a3ff // method "optInToApplication()void"
	txna ApplicationArgs 0
	match *abi_route_optInToApplication

	// this contract does not implement the given ABI method for call OptIn
	err
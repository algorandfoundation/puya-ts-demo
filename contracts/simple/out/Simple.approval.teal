#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 1 32 0
    bytecblock "counter" 0x151f7c75
    txn ApplicationID
    bnz main_after_if_else@2
    // contracts/simple/simple.algo.ts:10
    // counter = GlobalState<uint64>({ key: "counter", initialValue: 0 });
    bytec_0 // "counter"
    intc_2 // 0
    app_global_put

main_after_if_else@2:
    // contracts/simple/simple.algo.ts:9
    // export default class Simple extends Contract {
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@10
    pushbytess 0x9fab8610 0x2e0c5a47 0xac976e02 0x091b32a7 // method "incr(uint64)void", method "decr(uint64)void", method "add(uint256,uint256)uint256", method "sub(uint256,uint256)uint256"
    txna ApplicationArgs 0
    match incr decr add sub
    err

main_create_NoOp@10:
    // contracts/simple/simple.algo.ts:9
    // export default class Simple extends Contract {
    pushbytes 0xb8447b36 // method "createApplication()void"
    txna ApplicationArgs 0
    match main_createApplication_route@11
    err

main_createApplication_route@11:
    // contracts/simple/simple.algo.ts:16
    // @abimethod({ onCreate: "require" })
    intc_0 // 1
    return


// contracts/simple/simple.algo.ts::Simple.incr[routing]() -> void:
incr:
    // contracts/simple/simple.algo.ts:19
    // incr(i: uint64): void {
    txna ApplicationArgs 1
    btoi
    // contracts/simple/simple.algo.ts:13
    // this.counter.value = this.counter.value + i;
    intc_2 // 0
    // contracts/simple/simple.algo.ts:10
    // counter = GlobalState<uint64>({ key: "counter", initialValue: 0 });
    bytec_0 // "counter"
    // contracts/simple/simple.algo.ts:13
    // this.counter.value = this.counter.value + i;
    app_global_get_ex
    assert // check GlobalState exists
    +
    // contracts/simple/simple.algo.ts:10
    // counter = GlobalState<uint64>({ key: "counter", initialValue: 0 });
    bytec_0 // "counter"
    // contracts/simple/simple.algo.ts:13
    // this.counter.value = this.counter.value + i;
    swap
    app_global_put
    // contracts/simple/simple.algo.ts:19
    // incr(i: uint64): void {
    intc_0 // 1
    return


// contracts/simple/simple.algo.ts::Simple.decr[routing]() -> void:
decr:
    // contracts/simple/simple.algo.ts:23
    // decr(i: uint64): void {
    txna ApplicationArgs 1
    btoi
    // contracts/simple/simple.algo.ts:24
    // this.counter.value = this.counter.value - i;
    intc_2 // 0
    // contracts/simple/simple.algo.ts:10
    // counter = GlobalState<uint64>({ key: "counter", initialValue: 0 });
    bytec_0 // "counter"
    // contracts/simple/simple.algo.ts:24
    // this.counter.value = this.counter.value - i;
    app_global_get_ex
    assert // check GlobalState exists
    swap
    -
    // contracts/simple/simple.algo.ts:10
    // counter = GlobalState<uint64>({ key: "counter", initialValue: 0 });
    bytec_0 // "counter"
    // contracts/simple/simple.algo.ts:24
    // this.counter.value = this.counter.value - i;
    swap
    app_global_put
    // contracts/simple/simple.algo.ts:23
    // decr(i: uint64): void {
    intc_0 // 1
    return


// contracts/simple/simple.algo.ts::Simple.add[routing]() -> void:
add:
    // contracts/simple/simple.algo.ts:27
    // add(a: Uint256, b: Uint256): Uint256 {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // contracts/simple/simple.algo.ts:28
    // return new Uint256(a.asBigUint() + b.asBigUint());
    b+
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    intc_1 // 32
    bzero
    b|
    // contracts/simple/simple.algo.ts:27
    // add(a: Uint256, b: Uint256): Uint256 {
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// contracts/simple/simple.algo.ts::Simple.sub[routing]() -> void:
sub:
    // contracts/simple/simple.algo.ts:31
    // sub(a: Uint256, b: Uint256): Uint256 {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // contracts/simple/simple.algo.ts:32
    // return new Uint256(a.asBigUint() - b.asBigUint());
    b-
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    intc_1 // 32
    bzero
    b|
    // contracts/simple/simple.algo.ts:31
    // sub(a: Uint256, b: Uint256): Uint256 {
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

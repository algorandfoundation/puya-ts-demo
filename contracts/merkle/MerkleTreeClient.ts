/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^2
 */
import * as algokit from "@algorandfoundation/algokit-utils";
import type {
  AppCallTransactionResult,
  AppCallTransactionResultOfType,
  CoreAppCallArgs,
  RawAppCallArgs,
  AppState,
  TealTemplateParams,
  ABIAppCallArg,
} from "@algorandfoundation/algokit-utils/types/app";
import type {
  AppClientCallCoreParams,
  AppClientCompilationParams,
  AppClientDeployCoreParams,
  AppDetails,
  ApplicationClient,
} from "@algorandfoundation/algokit-utils/types/app-client";
import type { AppSpec } from "@algorandfoundation/algokit-utils/types/app-spec";
import type {
  SendTransactionResult,
  TransactionToSign,
  SendTransactionFrom,
} from "@algorandfoundation/algokit-utils/types/transaction";
import type { ABIResult, TransactionWithSigner, modelsv2 } from "algosdk";
import {
  Algodv2,
  OnApplicationComplete,
  Transaction,
  AtomicTransactionComposer,
} from "algosdk";
export const APP_SPEC: AppSpec = {
  hints: {
    "deleteApplication()void": {
      call_config: {
        delete_application: "CALL",
      },
    },
    "createApplication()void": {
      call_config: {
        no_op: "CREATE",
      },
    },
    "verify(byte[],byte[33][3])void": {
      call_config: {
        no_op: "CALL",
      },
    },
    "appendLeaf(byte[],byte[33][3])void": {
      call_config: {
        no_op: "CALL",
      },
    },
    "updateLeaf(byte[],byte[],byte[33][3])void": {
      call_config: {
        no_op: "CALL",
      },
    },
  },
  bare_call_config: {
    no_op: "NEVER",
    opt_in: "NEVER",
    close_out: "NEVER",
    update_application: "NEVER",
    delete_application: "NEVER",
  },
  schema: {
    local: {
      declared: {},
      reserved: {},
    },
    global: {
      declared: {
        root: {
          type: "bytes",
          key: "root",
        },
        size: {
          type: "uint64",
          key: "size",
        },
      },
      reserved: {},
    },
  },
  state: {
    global: {
      num_byte_slices: 1,
      num_uints: 1,
    },
    local: {
      num_byte_slices: 0,
      num_uints: 0,
    },
  },
  source: {
    approval:
      "I3ByYWdtYSB2ZXJzaW9uIDEwCmludGNibG9jayAxIDMzIDAgOTkgMwpieXRlY2Jsb2NrIDB4IDB4NzI2ZjZmNzQgMHhlM2IwYzQ0Mjk4ZmMxYzE0OWFmYmY0Yzg5OTZmYjkyNDI3YWU0MWU0NjQ5YjkzNGNhNDk1OTkxYjc4NTJiODU1MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAgMHg3MzY5N2E2NQoKLy8gVGhpcyBURUFMIHdhcyBnZW5lcmF0ZWQgYnkgVEVBTFNjcmlwdCB2MC4xMDUuNQovLyBodHRwczovL2dpdGh1Yi5jb20vYWxnb3JhbmRmb3VuZGF0aW9uL1RFQUxTY3JpcHQKCi8vIFRoaXMgY29udHJhY3QgaXMgY29tcGxpYW50IHdpdGggYW5kL29yIGltcGxlbWVudHMgdGhlIGZvbGxvd2luZyBBUkNzOiBbIEFSQzQgXQoKLy8gVGhlIGZvbGxvd2luZyB0ZW4gbGluZXMgb2YgVEVBTCBoYW5kbGUgaW5pdGlhbCBwcm9ncmFtIGZsb3cKLy8gVGhpcyBwYXR0ZXJuIGlzIHVzZWQgdG8gbWFrZSBpdCBlYXN5IGZvciBhbnlvbmUgdG8gcGFyc2UgdGhlIHN0YXJ0IG9mIHRoZSBwcm9ncmFtIGFuZCBkZXRlcm1pbmUgaWYgYSBzcGVjaWZpYyBhY3Rpb24gaXMgYWxsb3dlZAovLyBIZXJlLCBhY3Rpb24gcmVmZXJzIHRvIHRoZSBPbkNvbXBsZXRlIGluIGNvbWJpbmF0aW9uIHdpdGggd2hldGhlciB0aGUgYXBwIGlzIGJlaW5nIGNyZWF0ZWQgb3IgY2FsbGVkCi8vIEV2ZXJ5IHBvc3NpYmxlIGFjdGlvbiBmb3IgdGhpcyBjb250cmFjdCBpcyByZXByZXNlbnRlZCBpbiB0aGUgc3dpdGNoIHN0YXRlbWVudAovLyBJZiB0aGUgYWN0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGUgY29udHJhY3QsIGl0cyByZXNwZWN0aXZlIGJyYW5jaCB3aWxsIGJlICIqTk9UX0lNUExFTUVOVEVEIiB3aGljaCBqdXN0IGNvbnRhaW5zICJlcnIiCnR4biBBcHBsaWNhdGlvbklECiEKcHVzaGludCA2CioKdHhuIE9uQ29tcGxldGlvbgorCnN3aXRjaCAqY2FsbF9Ob09wICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKmNhbGxfRGVsZXRlQXBwbGljYXRpb24gKmNyZWF0ZV9Ob09wICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRAoKKk5PVF9JTVBMRU1FTlRFRDoKCS8vIFRoZSByZXF1ZXN0ZWQgYWN0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGlzIGNvbnRyYWN0LiBBcmUgeW91IHVzaW5nIHRoZSBjb3JyZWN0IE9uQ29tcGxldGU/IERpZCB5b3Ugc2V0IHlvdXIgYXBwIElEPwoJZXJyCgovLyBjYWxjSW5pdFJvb3QoKTogYnl0ZXMzMgpjYWxjSW5pdFJvb3Q6Cglwcm90byAwIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoJZHVwCgoJLy8gY29udHJhY3RzL21lcmtsZS9tZXJrbGUuYWxnby50czoxOAoJLy8gcmVzdWx0ID0gaGV4KEVNUFRZX0hBU0gpIGFzIGJ5dGVzMzIKCWJ5dGVjIDIgLy8gMHhlM2IwYzQ0Mjk4ZmMxYzE0OWFmYmY0Yzg5OTZmYjkyNDI3YWU0MWU0NjQ5YjkzNGNhNDk1OTkxYjc4NTJiODU1MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAoJYnl0ZWMgMCAvLyAweAoJZHVwCgliPT0KCWFzc2VydAoJZXh0cmFjdCAwIDMyCglmcmFtZV9idXJ5IDAgLy8gcmVzdWx0OiBieXRlWzMyXQoKCS8vIGNvbnRyYWN0cy9tZXJrbGUvbWVya2xlLmFsZ28udHM6MjAKCS8vIGZvciAobGV0IGkgPSAwOyBpIDwgVFJFRV9ERVBUSDsgaSA9IGkgKyAxKQoJaW50YyAyIC8vIDAKCWZyYW1lX2J1cnkgMSAvLyBpOiB1aW50NjQKCipmb3JfMDoKCS8vIGNvbnRyYWN0cy9tZXJrbGUvbWVya2xlLmFsZ28udHM6MjAKCS8vIGkgPCBUUkVFX0RFUFRICglmcmFtZV9kaWcgMSAvLyBpOiB1aW50NjQKCWludGMgNCAvLyAzCgk8CglieiAqZm9yXzBfZW5kCgoJLy8gY29udHJhY3RzL21lcmtsZS9tZXJrbGUuYWxnby50czoyMQoJLy8gcmVzdWx0ID0gc2hhMjU2KHJlc3VsdCArIHJlc3VsdCkKCWZyYW1lX2RpZyAwIC8vIHJlc3VsdDogYnl0ZVszMl0KCWZyYW1lX2RpZyAwIC8vIHJlc3VsdDogYnl0ZVszMl0KCWNvbmNhdAoJc2hhMjU2CglmcmFtZV9idXJ5IDAgLy8gcmVzdWx0OiBieXRlWzMyXQoKKmZvcl8wX2NvbnRpbnVlOgoJLy8gY29udHJhY3RzL21lcmtsZS9tZXJrbGUuYWxnby50czoyMAoJLy8gaSA9IGkgKyAxCglmcmFtZV9kaWcgMSAvLyBpOiB1aW50NjQKCWludGMgMCAvLyAxCgkrCglmcmFtZV9idXJ5IDEgLy8gaTogdWludDY0CgliICpmb3JfMAoKKmZvcl8wX2VuZDoKCS8vIGNvbnRyYWN0cy9tZXJrbGUvbWVya2xlLmFsZ28udHM6MjQKCS8vIHJldHVybiByZXN1bHQ7CglmcmFtZV9kaWcgMCAvLyByZXN1bHQ6IGJ5dGVbMzJdCgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gMQoJcmV0c3ViCgovLyBoYXNoQ29uY2F0KGxlZnQ6IGJ5dGVzMzIsIHJpZ2h0OiBieXRlczMyKTogYnl0ZXMzMgpoYXNoQ29uY2F0OgoJcHJvdG8gMiAxCgoJLy8gY29udHJhY3RzL21lcmtsZS9tZXJrbGUuYWxnby50czoyOAoJLy8gcmV0dXJuIHNoYTI1NihsZWZ0ICsgcmlnaHQpOwoJZnJhbWVfZGlnIC0xIC8vIGxlZnQ6IGJ5dGVzMzIKCWZyYW1lX2RpZyAtMiAvLyByaWdodDogYnl0ZXMzMgoJY29uY2F0CglzaGEyNTYKCXJldHN1YgoKLy8gaXNSaWdodFNpYmxpbmcoZWxlbTogQnJhbmNoKTogYm9vbGVhbgppc1JpZ2h0U2libGluZzoKCXByb3RvIDEgMQoKCS8vIGNvbnRyYWN0cy9tZXJrbGUvbWVya2xlLmFsZ28udHM6MzIKCS8vIHJldHVybiBnZXRieXRlKGVsZW0sIDApID09PSBSSUdIVF9TSUJMSU5HX1BSRUZJWDsKCWZyYW1lX2RpZyAtMSAvLyBlbGVtOiBCcmFuY2gKCWludGMgMiAvLyAwCglnZXRieXRlCglwdXNoaW50IDE3MAoJPT0KCXJldHN1YgoKLy8gY2FsY1Jvb3QobGVhZjogYnl0ZXMzMiwgcGF0aDogUGF0aCk6IGJ5dGVzMzIKY2FsY1Jvb3Q6Cglwcm90byAyIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoJZHVwCgoJLy8gY29udHJhY3RzL21lcmtsZS9tZXJrbGUuYWxnby50czozOAoJLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBUUkVFX0RFUFRIOyBpID0gaSArIDEpCglpbnRjIDIgLy8gMAoJZnJhbWVfYnVyeSAwIC8vIGk6IHVpbnQ2NAoKKmZvcl8xOgoJLy8gY29udHJhY3RzL21lcmtsZS9tZXJrbGUuYWxnby50czozOAoJLy8gaSA8IFRSRUVfREVQVEgKCWZyYW1lX2RpZyAwIC8vIGk6IHVpbnQ2NAoJaW50YyA0IC8vIDMKCTwKCWJ6ICpmb3JfMV9lbmQKCWZyYW1lX2RpZyAwIC8vIGk6IHVpbnQ2NAoJZnJhbWVfYnVyeSAxIC8vIGFjY2Vzc29yOiBhY2Nlc3Nvci8vMC8vZWxlbQoKCS8vICppZjBfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvbWVya2xlL21lcmtsZS5hbGdvLnRzOjQxCgkvLyB0aGlzLmlzUmlnaHRTaWJsaW5nKGVsZW0pCglmcmFtZV9kaWcgLTIgLy8gcGF0aDogUGF0aAoJZnJhbWVfZGlnIDEgLy8gc2F2ZWQgYWNjZXNzb3I6IGFjY2Vzc29yLy8wLy9lbGVtCglpbnRjIDEgLy8gMzMKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJaW50YyAxIC8vIDMzCglleHRyYWN0MwoJY2FsbHN1YiBpc1JpZ2h0U2libGluZwoJYnogKmlmMF9lbHNlCgoJLy8gKmlmMF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvbWVya2xlL21lcmtsZS5hbGdvLnRzOjQyCgkvLyByZXN1bHQgPSB0aGlzLmhhc2hDb25jYXQocmVzdWx0LCBleHRyYWN0MyhlbGVtLCAxLCAzMikgYXMgYnl0ZXMzMikKCWZyYW1lX2RpZyAtMiAvLyBwYXRoOiBQYXRoCglmcmFtZV9kaWcgMSAvLyBzYXZlZCBhY2Nlc3NvcjogYWNjZXNzb3IvLzAvL2VsZW0KCWludGMgMSAvLyAzMwoJKiAvLyBhY2MgKiB0eXBlTGVuZ3RoCglpbnRjIDEgLy8gMzMKCWV4dHJhY3QzCglleHRyYWN0IDEgMzIKCWJ5dGVjIDMgLy8gMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwCgljb25jYXQKCWR1cAoJZXh0cmFjdCAzMiAwCglieXRlYyAwIC8vIDB4CgliPT0KCWFzc2VydAoJZXh0cmFjdCAwIDMyCglmcmFtZV9kaWcgLTEgLy8gbGVhZjogYnl0ZXMzMgoJY2FsbHN1YiBoYXNoQ29uY2F0CglmcmFtZV9idXJ5IC0xIC8vIHJlc3VsdDogYnl0ZXMzMgoJYiAqaWYwX2VuZAoKKmlmMF9lbHNlOgoJLy8gY29udHJhY3RzL21lcmtsZS9tZXJrbGUuYWxnby50czo0NAoJLy8gcmVzdWx0ID0gdGhpcy5oYXNoQ29uY2F0KGV4dHJhY3QzKGVsZW0sIDEsIDMyKSBhcyBieXRlczMyLCByZXN1bHQpCglmcmFtZV9kaWcgLTEgLy8gbGVhZjogYnl0ZXMzMgoJZnJhbWVfZGlnIC0yIC8vIHBhdGg6IFBhdGgKCWZyYW1lX2RpZyAxIC8vIHNhdmVkIGFjY2Vzc29yOiBhY2Nlc3Nvci8vMC8vZWxlbQoJaW50YyAxIC8vIDMzCgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCWludGMgMSAvLyAzMwoJZXh0cmFjdDMKCWV4dHJhY3QgMSAzMgoJYnl0ZWMgMyAvLyAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAKCWNvbmNhdAoJZHVwCglleHRyYWN0IDMyIDAKCWJ5dGVjIDAgLy8gMHgKCWI9PQoJYXNzZXJ0CglleHRyYWN0IDAgMzIKCWNhbGxzdWIgaGFzaENvbmNhdAoJZnJhbWVfYnVyeSAtMSAvLyByZXN1bHQ6IGJ5dGVzMzIKCippZjBfZW5kOgoKKmZvcl8xX2NvbnRpbnVlOgoJLy8gY29udHJhY3RzL21lcmtsZS9tZXJrbGUuYWxnby50czozOAoJLy8gaSA9IGkgKyAxCglmcmFtZV9kaWcgMCAvLyBpOiB1aW50NjQKCWludGMgMCAvLyAxCgkrCglmcmFtZV9idXJ5IDAgLy8gaTogdWludDY0CgliICpmb3JfMQoKKmZvcl8xX2VuZDoKCS8vIGNvbnRyYWN0cy9tZXJrbGUvbWVya2xlLmFsZ28udHM6NDgKCS8vIHJldHVybiByZXN1bHQ7CglmcmFtZV9kaWcgLTEgLy8gbGVhZjogYnl0ZXMzMgoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDEKCXJldHN1YgoKLy8gZGVsZXRlQXBwbGljYXRpb24oKXZvaWQKKmFiaV9yb3V0ZV9kZWxldGVBcHBsaWNhdGlvbjoKCS8vIGV4ZWN1dGUgZGVsZXRlQXBwbGljYXRpb24oKXZvaWQKCWNhbGxzdWIgZGVsZXRlQXBwbGljYXRpb24KCWludGMgMCAvLyAxCglyZXR1cm4KCi8vIGRlbGV0ZUFwcGxpY2F0aW9uKCk6IHZvaWQKZGVsZXRlQXBwbGljYXRpb246Cglwcm90byAwIDAKCgkvLyBjb250cmFjdHMvbWVya2xlL21lcmtsZS5hbGdvLnRzOjUyCgkvLyB2ZXJpZnlBcHBDYWxsVHhuKHRoaXMudHhuLCB7IHNlbmRlcjogdGhpcy5hcHAuY3JlYXRvciB9KQoJLy8gdmVyaWZ5IHNlbmRlcgoJdHhuIFNlbmRlcgoJdHhuYSBBcHBsaWNhdGlvbnMgMAoJYXBwX3BhcmFtc19nZXQgQXBwQ3JlYXRvcgoJcG9wCgk9PQoKCS8vIHRyYW5zYWN0aW9uIHZlcmlmaWNhdGlvbiBmYWlsZWQ6IHsidHhuIjoidGhpcy50eG4iLCJmaWVsZCI6InNlbmRlciIsImV4cGVjdGVkIjoidGhpcy5hcHAuY3JlYXRvciJ9Cglhc3NlcnQKCXJldHN1YgoKLy8gY3JlYXRlQXBwbGljYXRpb24oKXZvaWQKKmFiaV9yb3V0ZV9jcmVhdGVBcHBsaWNhdGlvbjoKCS8vIGV4ZWN1dGUgY3JlYXRlQXBwbGljYXRpb24oKXZvaWQKCWNhbGxzdWIgY3JlYXRlQXBwbGljYXRpb24KCWludGMgMCAvLyAxCglyZXR1cm4KCi8vIGNyZWF0ZUFwcGxpY2F0aW9uKCk6IHZvaWQKY3JlYXRlQXBwbGljYXRpb246Cglwcm90byAwIDAKCgkvLyBjb250cmFjdHMvbWVya2xlL21lcmtsZS5hbGdvLnRzOjU2CgkvLyB0aGlzLnJvb3QudmFsdWUgPSB0aGlzLmNhbGNJbml0Um9vdCgpCglieXRlYyAxIC8vICAicm9vdCIKCWNhbGxzdWIgY2FsY0luaXRSb290CglhcHBfZ2xvYmFsX3B1dAoJcmV0c3ViCgovLyB2ZXJpZnkoYnl0ZVtdLGJ5dGVbMzNdWzNdKXZvaWQKKmFiaV9yb3V0ZV92ZXJpZnk6CgkvLyBwYXRoOiBieXRlWzMzXVszXQoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludGMgMyAvLyA5OQoJPT0KCgkvLyBhcmd1bWVudCAwIChwYXRoKSBmb3IgdmVyaWZ5IG11c3QgYmUgYSBieXRlWzMzXVszXQoJYXNzZXJ0CgoJLy8gZGF0YTogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgdmVyaWZ5KGJ5dGVbXSxieXRlWzMzXVszXSl2b2lkCgljYWxsc3ViIHZlcmlmeQoJaW50YyAwIC8vIDEKCXJldHVybgoKLy8gdmVyaWZ5KGRhdGE6IGJ5dGVzLCBwYXRoOiBQYXRoKTogdm9pZAp2ZXJpZnk6Cglwcm90byAyIDAKCgkvLyBjb250cmFjdHMvbWVya2xlL21lcmtsZS5hbGdvLnRzOjYwCgkvLyBhc3NlcnQodGhpcy5yb290LnZhbHVlID09PSB0aGlzLmNhbGNSb290KHNoYTI1NihkYXRhKSwgcGF0aCkpCglieXRlYyAxIC8vICAicm9vdCIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9kaWcgLTIgLy8gcGF0aDogUGF0aAoJZnJhbWVfZGlnIC0xIC8vIGRhdGE6IGJ5dGVzCglzaGEyNTYKCWNhbGxzdWIgY2FsY1Jvb3QKCT09Cglhc3NlcnQKCXJldHN1YgoKLy8gYXBwZW5kTGVhZihieXRlW10sYnl0ZVszM11bM10pdm9pZAoqYWJpX3JvdXRlX2FwcGVuZExlYWY6CgkvLyBwYXRoOiBieXRlWzMzXVszXQoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludGMgMyAvLyA5OQoJPT0KCgkvLyBhcmd1bWVudCAwIChwYXRoKSBmb3IgYXBwZW5kTGVhZiBtdXN0IGJlIGEgYnl0ZVszM11bM10KCWFzc2VydAoKCS8vIGRhdGE6IGJ5dGVbXQoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZXh0cmFjdCAyIDAKCgkvLyBleGVjdXRlIGFwcGVuZExlYWYoYnl0ZVtdLGJ5dGVbMzNdWzNdKXZvaWQKCWNhbGxzdWIgYXBwZW5kTGVhZgoJaW50YyAwIC8vIDEKCXJldHVybgoKLy8gYXBwZW5kTGVhZihkYXRhOiBieXRlcywgcGF0aDogUGF0aCk6IHZvaWQKYXBwZW5kTGVhZjoKCXByb3RvIDIgMAoKCS8vIGNvbnRyYWN0cy9tZXJrbGUvbWVya2xlLmFsZ28udHM6NjQKCS8vIGFzc2VydChkYXRhICE9PSAiIikKCWZyYW1lX2RpZyAtMSAvLyBkYXRhOiBieXRlcwoJYnl0ZWMgMCAvLyAgIiIKCSE9Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvbWVya2xlL21lcmtsZS5hbGdvLnRzOjY1CgkvLyBhc3NlcnQodGhpcy5yb290LnZhbHVlID09PSB0aGlzLmNhbGNSb290KGhleChFTVBUWV9IQVNIKSBhcyBieXRlczMyLCBwYXRoKSkKCWJ5dGVjIDEgLy8gICJyb290IgoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2RpZyAtMiAvLyBwYXRoOiBQYXRoCglieXRlYyAyIC8vIDB4ZTNiMGM0NDI5OGZjMWMxNDlhZmJmNGM4OTk2ZmI5MjQyN2FlNDFlNDY0OWI5MzRjYTQ5NTk5MWI3ODUyYjg1NTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAKCWJ5dGVjIDAgLy8gMHgKCWR1cAoJYj09Cglhc3NlcnQKCWV4dHJhY3QgMCAzMgoJY2FsbHN1YiBjYWxjUm9vdAoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9tZXJrbGUvbWVya2xlLmFsZ28udHM6NjcKCS8vIHRoaXMucm9vdC52YWx1ZSA9IHRoaXMuY2FsY1Jvb3Qoc2hhMjU2KGRhdGEpLCBwYXRoKQoJYnl0ZWMgMSAvLyAgInJvb3QiCglmcmFtZV9kaWcgLTIgLy8gcGF0aDogUGF0aAoJZnJhbWVfZGlnIC0xIC8vIGRhdGE6IGJ5dGVzCglzaGEyNTYKCWNhbGxzdWIgY2FsY1Jvb3QKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL21lcmtsZS9tZXJrbGUuYWxnby50czo2OQoJLy8gdGhpcy5zaXplLnZhbHVlID0gdGhpcy5zaXplLnZhbHVlICsgMQoJYnl0ZWMgNCAvLyAgInNpemUiCglkdXAKCWFwcF9nbG9iYWxfZ2V0CglpbnRjIDAgLy8gMQoJKwoJYXBwX2dsb2JhbF9wdXQKCXJldHN1YgoKLy8gdXBkYXRlTGVhZihieXRlW10sYnl0ZVtdLGJ5dGVbMzNdWzNdKXZvaWQKKmFiaV9yb3V0ZV91cGRhdGVMZWFmOgoJLy8gcGF0aDogYnl0ZVszM11bM10KCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWR1cAoJbGVuCglpbnRjIDMgLy8gOTkKCT09CgoJLy8gYXJndW1lbnQgMCAocGF0aCkgZm9yIHVwZGF0ZUxlYWYgbXVzdCBiZSBhIGJ5dGVbMzNdWzNdCglhc3NlcnQKCgkvLyBuZXdEYXRhOiBieXRlW10KCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWV4dHJhY3QgMiAwCgoJLy8gb2xkRGF0YTogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgdXBkYXRlTGVhZihieXRlW10sYnl0ZVtdLGJ5dGVbMzNdWzNdKXZvaWQKCWNhbGxzdWIgdXBkYXRlTGVhZgoJaW50YyAwIC8vIDEKCXJldHVybgoKLy8gdXBkYXRlTGVhZihvbGREYXRhOiBieXRlcywgbmV3RGF0YTogYnl0ZXMsIHBhdGg6IFBhdGgpOiB2b2lkCnVwZGF0ZUxlYWY6Cglwcm90byAzIDAKCgkvLyBjb250cmFjdHMvbWVya2xlL21lcmtsZS5hbGdvLnRzOjczCgkvLyBhc3NlcnQobmV3RGF0YSAhPT0gIiIpCglmcmFtZV9kaWcgLTIgLy8gbmV3RGF0YTogYnl0ZXMKCWJ5dGVjIDAgLy8gICIiCgkhPQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL21lcmtsZS9tZXJrbGUuYWxnby50czo3NAoJLy8gYXNzZXJ0KHRoaXMucm9vdC52YWx1ZSA9PT0gdGhpcy5jYWxjUm9vdChzaGEyNTYob2xkRGF0YSksIHBhdGgpKQoJYnl0ZWMgMSAvLyAgInJvb3QiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIC0zIC8vIHBhdGg6IFBhdGgKCWZyYW1lX2RpZyAtMSAvLyBvbGREYXRhOiBieXRlcwoJc2hhMjU2CgljYWxsc3ViIGNhbGNSb290Cgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL21lcmtsZS9tZXJrbGUuYWxnby50czo3NgoJLy8gdGhpcy5yb290LnZhbHVlID0gdGhpcy5jYWxjUm9vdChzaGEyNTYobmV3RGF0YSksIHBhdGgpCglieXRlYyAxIC8vICAicm9vdCIKCWZyYW1lX2RpZyAtMyAvLyBwYXRoOiBQYXRoCglmcmFtZV9kaWcgLTIgLy8gbmV3RGF0YTogYnl0ZXMKCXNoYTI1NgoJY2FsbHN1YiBjYWxjUm9vdAoJYXBwX2dsb2JhbF9wdXQKCXJldHN1YgoKKmNyZWF0ZV9Ob09wOgoJcHVzaGJ5dGVzIDB4Yjg0NDdiMzYgLy8gbWV0aG9kICJjcmVhdGVBcHBsaWNhdGlvbigpdm9pZCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoICphYmlfcm91dGVfY3JlYXRlQXBwbGljYXRpb24KCgkvLyB0aGlzIGNvbnRyYWN0IGRvZXMgbm90IGltcGxlbWVudCB0aGUgZ2l2ZW4gQUJJIG1ldGhvZCBmb3IgY3JlYXRlIE5vT3AKCWVycgoKKmNhbGxfTm9PcDoKCXB1c2hieXRlcyAweDUwNmNiOGQ4IC8vIG1ldGhvZCAidmVyaWZ5KGJ5dGVbXSxieXRlWzMzXVszXSl2b2lkIgoJcHVzaGJ5dGVzIDB4MDRmNjMyMzggLy8gbWV0aG9kICJhcHBlbmRMZWFmKGJ5dGVbXSxieXRlWzMzXVszXSl2b2lkIgoJcHVzaGJ5dGVzIDB4MjU1ZDkzZTMgLy8gbWV0aG9kICJ1cGRhdGVMZWFmKGJ5dGVbXSxieXRlW10sYnl0ZVszM11bM10pdm9pZCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoICphYmlfcm91dGVfdmVyaWZ5ICphYmlfcm91dGVfYXBwZW5kTGVhZiAqYWJpX3JvdXRlX3VwZGF0ZUxlYWYKCgkvLyB0aGlzIGNvbnRyYWN0IGRvZXMgbm90IGltcGxlbWVudCB0aGUgZ2l2ZW4gQUJJIG1ldGhvZCBmb3IgY2FsbCBOb09wCgllcnIKCipjYWxsX0RlbGV0ZUFwcGxpY2F0aW9uOgoJcHVzaGJ5dGVzIDB4MjQ4N2MzMmMgLy8gbWV0aG9kICJkZWxldGVBcHBsaWNhdGlvbigpdm9pZCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoICphYmlfcm91dGVfZGVsZXRlQXBwbGljYXRpb24KCgkvLyB0aGlzIGNvbnRyYWN0IGRvZXMgbm90IGltcGxlbWVudCB0aGUgZ2l2ZW4gQUJJIG1ldGhvZCBmb3IgY2FsbCBEZWxldGVBcHBsaWNhdGlvbgoJZXJy",
    clear: "I3ByYWdtYSB2ZXJzaW9uIDEw",
  },
  contract: {
    name: "MerkleTree",
    desc: "",
    methods: [
      {
        name: "deleteApplication",
        args: [],
        returns: {
          type: "void",
        },
      },
      {
        name: "createApplication",
        args: [],
        returns: {
          type: "void",
        },
      },
      {
        name: "verify",
        args: [
          {
            name: "data",
            type: "byte[]",
          },
          {
            name: "path",
            type: "byte[33][3]",
          },
        ],
        returns: {
          type: "void",
        },
      },
      {
        name: "appendLeaf",
        args: [
          {
            name: "data",
            type: "byte[]",
          },
          {
            name: "path",
            type: "byte[33][3]",
          },
        ],
        returns: {
          type: "void",
        },
      },
      {
        name: "updateLeaf",
        args: [
          {
            name: "oldData",
            type: "byte[]",
          },
          {
            name: "newData",
            type: "byte[]",
          },
          {
            name: "path",
            type: "byte[33][3]",
          },
        ],
        returns: {
          type: "void",
        },
      },
    ],
  },
};

/**
 * Defines an onCompletionAction of 'no_op'
 */
export type OnCompleteNoOp = {
  onCompleteAction?: "no_op" | OnApplicationComplete.NoOpOC;
};
/**
 * Defines an onCompletionAction of 'opt_in'
 */
export type OnCompleteOptIn = {
  onCompleteAction: "opt_in" | OnApplicationComplete.OptInOC;
};
/**
 * Defines an onCompletionAction of 'close_out'
 */
export type OnCompleteCloseOut = {
  onCompleteAction: "close_out" | OnApplicationComplete.CloseOutOC;
};
/**
 * Defines an onCompletionAction of 'delete_application'
 */
export type OnCompleteDelApp = {
  onCompleteAction:
    | "delete_application"
    | OnApplicationComplete.DeleteApplicationOC;
};
/**
 * Defines an onCompletionAction of 'update_application'
 */
export type OnCompleteUpdApp = {
  onCompleteAction:
    | "update_application"
    | OnApplicationComplete.UpdateApplicationOC;
};
/**
 * A state record containing a single unsigned integer
 */
export type IntegerState = {
  /**
   * Gets the state value as a BigInt
   */
  asBigInt(): bigint;
  /**
   * Gets the state value as a number.
   */
  asNumber(): number;
};
/**
 * A state record containing binary data
 */
export type BinaryState = {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array;
  /**
   * Gets the state value as a string
   */
  asString(): string;
};

/**
 * Defines the types of available calls and state of the MerkleTree smart contract.
 */
export type MerkleTree = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods: Record<
    "deleteApplication()void" | "deleteApplication",
    {
      argsObj: {};
      argsTuple: [];
      returns: void;
    }
  > &
    Record<
      "createApplication()void" | "createApplication",
      {
        argsObj: {};
        argsTuple: [];
        returns: void;
      }
    > &
    Record<
      "verify(byte[],byte[33][3])void" | "verify",
      {
        argsObj: {
          data: Uint8Array;
          path: [Uint8Array, Uint8Array, Uint8Array];
        };
        argsTuple: [
          data: Uint8Array,
          path: [Uint8Array, Uint8Array, Uint8Array],
        ];
        returns: void;
      }
    > &
    Record<
      "appendLeaf(byte[],byte[33][3])void" | "appendLeaf",
      {
        argsObj: {
          data: Uint8Array;
          path: [Uint8Array, Uint8Array, Uint8Array];
        };
        argsTuple: [
          data: Uint8Array,
          path: [Uint8Array, Uint8Array, Uint8Array],
        ];
        returns: void;
      }
    > &
    Record<
      "updateLeaf(byte[],byte[],byte[33][3])void" | "updateLeaf",
      {
        argsObj: {
          oldData: Uint8Array;
          newData: Uint8Array;
          path: [Uint8Array, Uint8Array, Uint8Array];
        };
        argsTuple: [
          oldData: Uint8Array,
          newData: Uint8Array,
          path: [Uint8Array, Uint8Array, Uint8Array],
        ];
        returns: void;
      }
    >;
  /**
   * Defines the shape of the global and local state of the application.
   */
  state: {
    global: {
      root?: BinaryState;
      size?: IntegerState;
    };
  };
};
/**
 * Defines the possible abi call signatures
 */
export type MerkleTreeSig = keyof MerkleTree["methods"];
/**
 * Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a bare call is made
 */
export type TypedCallParams<TSignature extends MerkleTreeSig | undefined> = {
  method: TSignature;
  methodArgs: TSignature extends undefined
    ? undefined
    : Array<ABIAppCallArg | undefined>;
} & AppClientCallCoreParams &
  CoreAppCallArgs;
/**
 * Defines the arguments required for a bare call
 */
export type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>;
/**
 * Maps a method signature from the MerkleTree smart contract to the method's arguments in either tuple of struct form
 */
export type MethodArgs<TSignature extends MerkleTreeSig> =
  MerkleTree["methods"][TSignature]["argsObj" | "argsTuple"];
/**
 * Maps a method signature from the MerkleTree smart contract to the method's return type
 */
export type MethodReturn<TSignature extends MerkleTreeSig> =
  MerkleTree["methods"][TSignature]["returns"];

/**
 * A factory for available 'create' calls
 */
export type MerkleTreeCreateCalls = (typeof MerkleTreeCallFactory)["create"];
/**
 * Defines supported create methods for this smart contract
 */
export type MerkleTreeCreateCallParams =
  TypedCallParams<"createApplication()void"> & OnCompleteNoOp;
/**
 * A factory for available 'delete' calls
 */
export type MerkleTreeDeleteCalls = (typeof MerkleTreeCallFactory)["delete"];
/**
 * Defines supported delete methods for this smart contract
 */
export type MerkleTreeDeleteCallParams =
  TypedCallParams<"deleteApplication()void">;
/**
 * Defines arguments required for the deploy method.
 */
export type MerkleTreeDeployArgs = {
  deployTimeParams?: TealTemplateParams;
  /**
   * A delegate which takes a create call factory and returns the create call params for this smart contract
   */
  createCall?: (
    callFactory: MerkleTreeCreateCalls,
  ) => MerkleTreeCreateCallParams;
  /**
   * A delegate which takes a delete call factory and returns the delete call params for this smart contract
   */
  deleteCall?: (
    callFactory: MerkleTreeDeleteCalls,
  ) => MerkleTreeDeleteCallParams;
};

/**
 * Exposes methods for constructing all available smart contract calls
 */
export abstract class MerkleTreeCallFactory {
  /**
   * Gets available create call factories
   */
  static get create() {
    return {
      /**
       * Constructs a create call for the MerkleTree smart contract using the createApplication()void ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      createApplication(
        args: MethodArgs<"createApplication()void">,
        params: AppClientCallCoreParams &
          CoreAppCallArgs &
          AppClientCompilationParams &
          OnCompleteNoOp = {},
      ) {
        return {
          method: "createApplication()void" as const,
          methodArgs: Array.isArray(args) ? args : [],
          ...params,
        };
      },
    };
  }

  /**
   * Gets available delete call factories
   */
  static get delete() {
    return {
      /**
       * Constructs a delete call for the MerkleTree smart contract using the deleteApplication()void ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      deleteApplication(
        args: MethodArgs<"deleteApplication()void">,
        params: AppClientCallCoreParams & CoreAppCallArgs = {},
      ) {
        return {
          method: "deleteApplication()void" as const,
          methodArgs: Array.isArray(args) ? args : [],
          ...params,
        };
      },
    };
  }

  /**
   * Constructs a no op call for the verify(byte[],byte[33][3])void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static verify(
    args: MethodArgs<"verify(byte[],byte[33][3])void">,
    params: AppClientCallCoreParams & CoreAppCallArgs,
  ) {
    return {
      method: "verify(byte[],byte[33][3])void" as const,
      methodArgs: Array.isArray(args) ? args : [args.data, args.path],
      ...params,
    };
  }
  /**
   * Constructs a no op call for the appendLeaf(byte[],byte[33][3])void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static appendLeaf(
    args: MethodArgs<"appendLeaf(byte[],byte[33][3])void">,
    params: AppClientCallCoreParams & CoreAppCallArgs,
  ) {
    return {
      method: "appendLeaf(byte[],byte[33][3])void" as const,
      methodArgs: Array.isArray(args) ? args : [args.data, args.path],
      ...params,
    };
  }
  /**
   * Constructs a no op call for the updateLeaf(byte[],byte[],byte[33][3])void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static updateLeaf(
    args: MethodArgs<"updateLeaf(byte[],byte[],byte[33][3])void">,
    params: AppClientCallCoreParams & CoreAppCallArgs,
  ) {
    return {
      method: "updateLeaf(byte[],byte[],byte[33][3])void" as const,
      methodArgs: Array.isArray(args)
        ? args
        : [args.oldData, args.newData, args.path],
      ...params,
    };
  }
}

/**
 * A client to make calls to the MerkleTree smart contract
 */
export class MerkleTreeClient {
  /**
   * The underlying `ApplicationClient` for when you want to have more flexibility
   */
  public readonly appClient: ApplicationClient;

  private readonly sender: SendTransactionFrom | undefined;

  /**
   * Creates a new instance of `MerkleTreeClient`
   *
   * @param appDetails appDetails The details to identify the app to deploy
   * @param algod An algod client instance
   */
  constructor(
    appDetails: AppDetails,
    private algod: Algodv2,
  ) {
    this.sender = appDetails.sender;
    this.appClient = algokit.getAppClient(
      {
        ...appDetails,
        app: APP_SPEC,
      },
      algod,
    );
  }

  /**
   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type
   *
   * @param result The AppCallTransactionResult to be mapped
   * @param returnValueFormatter An optional delegate to format the return value if required
   * @returns The smart contract response with an updated return value
   */
  protected mapReturnValue<TReturn>(
    result: AppCallTransactionResult,
    returnValueFormatter?: (value: any) => TReturn,
  ): AppCallTransactionResultOfType<TReturn> {
    if (result.return?.decodeError) {
      throw result.return.decodeError;
    }
    const returnValue =
      result.return?.returnValue !== undefined &&
      returnValueFormatter !== undefined
        ? returnValueFormatter(result.return.returnValue)
        : (result.return?.returnValue as TReturn | undefined);
    return { ...result, return: returnValue };
  }

  /**
   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP
   *
   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters
   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type
   * @returns The result of the smart contract call
   */
  public async call<TSignature extends keyof MerkleTree["methods"]>(
    typedCallParams: TypedCallParams<TSignature>,
    returnValueFormatter?: (value: any) => MethodReturn<TSignature>,
  ) {
    return this.mapReturnValue<MethodReturn<TSignature>>(
      await this.appClient.call(typedCallParams),
      returnValueFormatter,
    );
  }

  /**
   * Idempotently deploys the MerkleTree smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public deploy(
    params: MerkleTreeDeployArgs & AppClientDeployCoreParams = {},
  ): ReturnType<ApplicationClient["deploy"]> {
    const createArgs = params.createCall?.(MerkleTreeCallFactory.create);
    const deleteArgs = params.deleteCall?.(MerkleTreeCallFactory.delete);
    return this.appClient.deploy({
      ...params,
      deleteArgs,
      createArgs,
      createOnCompleteAction: createArgs?.onCompleteAction,
    });
  }

  /**
   * Gets available create methods
   */
  public get create() {
    const $this = this;
    return {
      /**
       * Creates a new instance of the MerkleTree smart contract using the createApplication()void ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The create result
       */
      async createApplication(
        args: MethodArgs<"createApplication()void">,
        params: AppClientCallCoreParams &
          AppClientCompilationParams &
          OnCompleteNoOp = {},
      ): Promise<
        AppCallTransactionResultOfType<MethodReturn<"createApplication()void">>
      > {
        return $this.mapReturnValue(
          await $this.appClient.create(
            MerkleTreeCallFactory.create.createApplication(args, params),
          ),
        );
      },
    };
  }

  /**
   * Gets available delete methods
   */
  public get delete() {
    const $this = this;
    return {
      /**
       * Deletes an existing instance of the MerkleTree smart contract using the deleteApplication()void ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The delete result
       */
      async deleteApplication(
        args: MethodArgs<"deleteApplication()void">,
        params: AppClientCallCoreParams = {},
      ): Promise<
        AppCallTransactionResultOfType<MethodReturn<"deleteApplication()void">>
      > {
        return $this.mapReturnValue(
          await $this.appClient.delete(
            MerkleTreeCallFactory.delete.deleteApplication(args, params),
          ),
        );
      },
    };
  }

  /**
   * Makes a clear_state call to an existing instance of the MerkleTree smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The clear_state result
   */
  public clearState(
    args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {},
  ) {
    return this.appClient.clearState(args);
  }

  /**
   * Calls the verify(byte[],byte[33][3])void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public verify(
    args: MethodArgs<"verify(byte[],byte[33][3])void">,
    params: AppClientCallCoreParams & CoreAppCallArgs = {},
  ) {
    return this.call(MerkleTreeCallFactory.verify(args, params));
  }

  /**
   * Calls the appendLeaf(byte[],byte[33][3])void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public appendLeaf(
    args: MethodArgs<"appendLeaf(byte[],byte[33][3])void">,
    params: AppClientCallCoreParams & CoreAppCallArgs = {},
  ) {
    return this.call(MerkleTreeCallFactory.appendLeaf(args, params));
  }

  /**
   * Calls the updateLeaf(byte[],byte[],byte[33][3])void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public updateLeaf(
    args: MethodArgs<"updateLeaf(byte[],byte[],byte[33][3])void">,
    params: AppClientCallCoreParams & CoreAppCallArgs = {},
  ) {
    return this.call(MerkleTreeCallFactory.updateLeaf(args, params));
  }

  /**
   * Extracts a binary state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns A BinaryState instance containing the state value, or undefined if the key was not found
   */
  private static getBinaryState(
    state: AppState,
    key: string,
  ): BinaryState | undefined {
    const value = state[key];
    if (!value) return undefined;
    if (!("valueRaw" in value))
      throw new Error(
        `Failed to parse state value for ${key}; received an int when expected a byte array`,
      );
    return {
      asString(): string {
        return value.value;
      },
      asByteArray(): Uint8Array {
        return value.valueRaw;
      },
    };
  }

  /**
   * Extracts a integer state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns An IntegerState instance containing the state value, or undefined if the key was not found
   */
  private static getIntegerState(
    state: AppState,
    key: string,
  ): IntegerState | undefined {
    const value = state[key];
    if (!value) return undefined;
    if ("valueRaw" in value)
      throw new Error(
        `Failed to parse state value for ${key}; received a byte array when expected a number`,
      );
    return {
      asBigInt() {
        return typeof value.value === "bigint"
          ? value.value
          : BigInt(value.value);
      },
      asNumber(): number {
        return typeof value.value === "bigint"
          ? Number(value.value)
          : value.value;
      },
    };
  }

  /**
   * Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value
   */
  public async getGlobalState(): Promise<MerkleTree["state"]["global"]> {
    const state = await this.appClient.getGlobalState();
    return {
      get root() {
        return MerkleTreeClient.getBinaryState(state, "root");
      },
      get size() {
        return MerkleTreeClient.getIntegerState(state, "size");
      },
    };
  }

  public compose(): MerkleTreeComposer {
    const client = this;
    const atc = new AtomicTransactionComposer();
    let promiseChain: Promise<unknown> = Promise.resolve();
    const resultMappers: Array<undefined | ((x: any) => any)> = [];
    return {
      verify(
        args: MethodArgs<"verify(byte[],byte[33][3])void">,
        params?: AppClientCallCoreParams & CoreAppCallArgs,
      ) {
        promiseChain = promiseChain.then(() =>
          client.verify(args, {
            ...params,
            sendParams: { ...params?.sendParams, skipSending: true, atc },
          }),
        );
        resultMappers.push(undefined);
        return this;
      },
      appendLeaf(
        args: MethodArgs<"appendLeaf(byte[],byte[33][3])void">,
        params?: AppClientCallCoreParams & CoreAppCallArgs,
      ) {
        promiseChain = promiseChain.then(() =>
          client.appendLeaf(args, {
            ...params,
            sendParams: { ...params?.sendParams, skipSending: true, atc },
          }),
        );
        resultMappers.push(undefined);
        return this;
      },
      updateLeaf(
        args: MethodArgs<"updateLeaf(byte[],byte[],byte[33][3])void">,
        params?: AppClientCallCoreParams & CoreAppCallArgs,
      ) {
        promiseChain = promiseChain.then(() =>
          client.updateLeaf(args, {
            ...params,
            sendParams: { ...params?.sendParams, skipSending: true, atc },
          }),
        );
        resultMappers.push(undefined);
        return this;
      },
      get delete() {
        const $this = this;
        return {
          deleteApplication(
            args: MethodArgs<"deleteApplication()void">,
            params?: AppClientCallCoreParams,
          ) {
            promiseChain = promiseChain.then(() =>
              client.delete.deleteApplication(args, {
                ...params,
                sendParams: { ...params?.sendParams, skipSending: true, atc },
              }),
            );
            resultMappers.push(undefined);
            return $this;
          },
        };
      },
      clearState(
        args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs,
      ) {
        promiseChain = promiseChain.then(() =>
          client.clearState({
            ...args,
            sendParams: { ...args?.sendParams, skipSending: true, atc },
          }),
        );
        resultMappers.push(undefined);
        return this;
      },
      addTransaction(
        txn:
          | TransactionWithSigner
          | TransactionToSign
          | Transaction
          | Promise<SendTransactionResult>,
        defaultSender?: SendTransactionFrom,
      ) {
        promiseChain = promiseChain.then(async () =>
          atc.addTransaction(
            await algokit.getTransactionWithSigner(
              txn,
              defaultSender ?? client.sender,
            ),
          ),
        );
        return this;
      },
      async atc() {
        await promiseChain;
        return atc;
      },
      async simulate() {
        await promiseChain;
        const result = await atc.simulate(client.algod);
        return result;
      },
      async execute() {
        await promiseChain;
        const result = await algokit.sendAtomicTransactionComposer(
          { atc, sendParams: {} },
          client.algod,
        );
        return {
          ...result,
          returns: result.returns?.map((val, i) =>
            resultMappers[i] !== undefined
              ? resultMappers[i]!(val.returnValue)
              : val.returnValue,
          ),
        };
      },
    } as unknown as MerkleTreeComposer;
  }
}
export type MerkleTreeComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the verify(byte[],byte[33][3])void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  verify(
    args: MethodArgs<"verify(byte[],byte[33][3])void">,
    params?: AppClientCallCoreParams & CoreAppCallArgs,
  ): MerkleTreeComposer<
    [...TReturns, MethodReturn<"verify(byte[],byte[33][3])void">]
  >;

  /**
   * Calls the appendLeaf(byte[],byte[33][3])void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  appendLeaf(
    args: MethodArgs<"appendLeaf(byte[],byte[33][3])void">,
    params?: AppClientCallCoreParams & CoreAppCallArgs,
  ): MerkleTreeComposer<
    [...TReturns, MethodReturn<"appendLeaf(byte[],byte[33][3])void">]
  >;

  /**
   * Calls the updateLeaf(byte[],byte[],byte[33][3])void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  updateLeaf(
    args: MethodArgs<"updateLeaf(byte[],byte[],byte[33][3])void">,
    params?: AppClientCallCoreParams & CoreAppCallArgs,
  ): MerkleTreeComposer<
    [...TReturns, MethodReturn<"updateLeaf(byte[],byte[],byte[33][3])void">]
  >;

  /**
   * Gets available delete methods
   */
  readonly delete: {
    /**
     * Deletes an existing instance of the MerkleTree smart contract using the deleteApplication()void ABI method.
     *
     * @param args The arguments for the smart contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    deleteApplication(
      args: MethodArgs<"deleteApplication()void">,
      params?: AppClientCallCoreParams,
    ): MerkleTreeComposer<
      [...TReturns, MethodReturn<"deleteApplication()void">]
    >;
  };

  /**
   * Makes a clear_state call to an existing instance of the MerkleTree smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(
    args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs,
  ): MerkleTreeComposer<[...TReturns, undefined]>;

  /**
   * Adds a transaction to the composer
   *
   * @param txn One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)
   * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not include a signer.
   */
  addTransaction(
    txn:
      | TransactionWithSigner
      | TransactionToSign
      | Transaction
      | Promise<SendTransactionResult>,
    defaultSender?: SendTransactionFrom,
  ): MerkleTreeComposer<TReturns>;
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  atc(): Promise<AtomicTransactionComposer>;
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(): Promise<MerkleTreeComposerSimulateResult>;
  /**
   * Executes the transaction group and returns the results
   */
  execute(): Promise<MerkleTreeComposerResults<TReturns>>;
};
export type MerkleTreeComposerSimulateResult = {
  methodResults: ABIResult[];
  simulateResponse: modelsv2.SimulateResponse;
};
export type MerkleTreeComposerResults<TReturns extends [...any[]]> = {
  returns: TReturns;
  groupId: string;
  txIds: string[];
  transactions: Transaction[];
};

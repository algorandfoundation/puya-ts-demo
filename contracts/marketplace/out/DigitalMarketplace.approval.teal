#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 1 0 4 48 50500
    bytecblock "listings" base32(AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA) 0x151f7c75000000000000c544 0x0000000000000000
    // contracts/marketplace/marketplace.algo.ts:30
    // export default class DigitalMarketplace extends arc4.Contract {
    txn NumAppArgs
    bz main_bare_routing@16
    pushbytess 0xbe4b31e3 0xa0cb3693 0xd98ef6a9 0x56efcfb5 0x12f08c98 0x9b4b8234 0x5a05bc57 0x1c80d714 0xcbc819e5 0xbc75ceb1 0xdd619204 // method "listingsBoxMbr()uint64", method "quantityPrice(uint64,uint64,uint64)uint64", method "getListingsMbr()uint64", method "allowAsset(pay,asset)void", method "firstDeposit(pay,axfer,uint64,uint64)void", method "deposit(axfer,uint64)void", method "setPrice(asset,uint64,uint64)void", method "buy(address,asset,uint64,pay,uint64)void", method "withdraw(asset,uint64)void", method "bid(address,asset,uint64,pay,uint64,uint64)void", method "acceptBid(asset,uint64)void"
    txna ApplicationArgs 0
    match main_listingsBoxMbr_route@3 main_quantityPrice_route@4 main_getListingsMbr_route@5 main_allowAsset_route@6 main_firstDeposit_route@7 main_deposit_route@8 main_setPrice_route@9 main_buy_route@10 main_withdraw_route@11 main_bid_route@12 main_acceptBid_route@13

main_after_if_else@20:
    // contracts/marketplace/marketplace.algo.ts:30
    // export default class DigitalMarketplace extends arc4.Contract {
    intc_1 // 0
    return

main_acceptBid_route@13:
    // contracts/marketplace/marketplace.algo.ts:291
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/marketplace/marketplace.algo.ts:30
    // export default class DigitalMarketplace extends arc4.Contract {
    txna ApplicationArgs 1
    btoi
    txnas Assets
    txna ApplicationArgs 2
    // contracts/marketplace/marketplace.algo.ts:291
    // @arc4.abimethod()
    callsub acceptBid
    intc_0 // 1
    return

main_bid_route@12:
    // contracts/marketplace/marketplace.algo.ts:242
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/marketplace/marketplace.algo.ts:30
    // export default class DigitalMarketplace extends arc4.Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    txnas Assets
    txna ApplicationArgs 3
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    // contracts/marketplace/marketplace.algo.ts:242
    // @arc4.abimethod()
    callsub bid
    intc_0 // 1
    return

main_withdraw_route@11:
    // contracts/marketplace/marketplace.algo.ts:207
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/marketplace/marketplace.algo.ts:30
    // export default class DigitalMarketplace extends arc4.Contract {
    txna ApplicationArgs 1
    btoi
    txnas Assets
    txna ApplicationArgs 2
    // contracts/marketplace/marketplace.algo.ts:207
    // @arc4.abimethod()
    callsub withdraw
    intc_0 // 1
    return

main_buy_route@10:
    // contracts/marketplace/marketplace.algo.ts:164
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/marketplace/marketplace.algo.ts:30
    // export default class DigitalMarketplace extends arc4.Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    txnas Assets
    txna ApplicationArgs 3
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 4
    btoi
    // contracts/marketplace/marketplace.algo.ts:164
    // @arc4.abimethod()
    callsub buy
    intc_0 // 1
    return

main_setPrice_route@9:
    // contracts/marketplace/marketplace.algo.ts:146
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/marketplace/marketplace.algo.ts:30
    // export default class DigitalMarketplace extends arc4.Contract {
    txna ApplicationArgs 1
    btoi
    txnas Assets
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // contracts/marketplace/marketplace.algo.ts:146
    // @arc4.abimethod()
    callsub setPrice
    intc_0 // 1
    return

main_deposit_route@8:
    // contracts/marketplace/marketplace.algo.ts:124
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/marketplace/marketplace.algo.ts:30
    // export default class DigitalMarketplace extends arc4.Contract {
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    // contracts/marketplace/marketplace.algo.ts:124
    // @arc4.abimethod()
    callsub deposit
    intc_0 // 1
    return

main_firstDeposit_route@7:
    // contracts/marketplace/marketplace.algo.ts:93
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/marketplace/marketplace.algo.ts:30
    // export default class DigitalMarketplace extends arc4.Contract {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // contracts/marketplace/marketplace.algo.ts:93
    // @arc4.abimethod()
    callsub firstDeposit
    intc_0 // 1
    return

main_allowAsset_route@6:
    // contracts/marketplace/marketplace.algo.ts:77
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/marketplace/marketplace.algo.ts:30
    // export default class DigitalMarketplace extends arc4.Contract {
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    btoi
    txnas Assets
    // contracts/marketplace/marketplace.algo.ts:77
    // @arc4.abimethod()
    callsub allowAsset
    intc_0 // 1
    return

main_getListingsMbr_route@5:
    // contracts/marketplace/marketplace.algo.ts:72
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec_2 // 0x151f7c75000000000000c544
    log
    intc_0 // 1
    return

main_quantityPrice_route@4:
    // contracts/marketplace/marketplace.algo.ts:53-57
    // quantityPrice(
    //   quantity: uint64,
    //   price: uint64,
    //   assetDecimals: uint64,
    // ): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/marketplace/marketplace.algo.ts:30
    // export default class DigitalMarketplace extends arc4.Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    // contracts/marketplace/marketplace.algo.ts:53-57
    // quantityPrice(
    //   quantity: uint64,
    //   price: uint64,
    //   assetDecimals: uint64,
    // ): uint64 {
    callsub quantityPrice
    itob
    pushbytes 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_listingsBoxMbr_route@3:
    // contracts/marketplace/marketplace.algo.ts:33
    // listingsBoxMbr(): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec_2 // 0x151f7c75000000000000c544
    log
    intc_0 // 1
    return

main_bare_routing@16:
    // contracts/marketplace/marketplace.algo.ts:30
    // export default class DigitalMarketplace extends arc4.Contract {
    txn OnCompletion
    bnz main_after_if_else@20
    txn ApplicationID
    !
    assert // can only call when creating
    intc_0 // 1
    return


// contracts/marketplace/marketplace.algo.ts::DigitalMarketplace.quantityPrice(quantity: uint64, price: uint64, assetDecimals: uint64) -> uint64:
quantityPrice:
    // contracts/marketplace/marketplace.algo.ts:53-57
    // quantityPrice(
    //   quantity: uint64,
    //   price: uint64,
    //   assetDecimals: uint64,
    // ): uint64 {
    proto 3 1
    // contracts/marketplace/marketplace.algo.ts:58
    // const [amountNotScaledHigh, amountNotScaledLow] = op.mulw(price, quantity);
    frame_dig -2
    frame_dig -3
    mulw
    // contracts/marketplace/marketplace.algo.ts:59
    // const [scalingFactorHigh, scalingFactorLow] = op.expw(10, assetDecimals);
    pushint 10 // 10
    frame_dig -1
    expw
    // contracts/marketplace/marketplace.algo.ts:61-66
    // op.divmodw(
    //   amountNotScaledHigh,
    //   amountNotScaledLow,
    //   scalingFactorHigh,
    //   scalingFactorLow,
    // );
    divmodw
    popn 2
    swap
    // contracts/marketplace/marketplace.algo.ts:67
    // assert(_quotientHigh === 0);
    !
    assert
    // contracts/marketplace/marketplace.algo.ts:69
    // return amountToBePaid;
    retsub


// contracts/marketplace/marketplace.algo.ts::DigitalMarketplace.allowAsset(mbrPay: uint64, asset: uint64) -> void:
allowAsset:
    // contracts/marketplace/marketplace.algo.ts:77-78
    // @arc4.abimethod()
    // allowAsset(mbrPay: gtxn.PaymentTxn, asset: Asset) {
    proto 2 0
    // contracts/marketplace/marketplace.algo.ts:79
    // assert(!Global.currentApplicationAddress.isOptedIn(asset));
    global CurrentApplicationAddress
    frame_dig -1
    asset_holding_get AssetBalance
    bury 1
    !
    assert
    // contracts/marketplace/marketplace.algo.ts:81
    // assert(mbrPay.receiver === Global.currentApplicationAddress);
    frame_dig -2
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert
    // contracts/marketplace/marketplace.algo.ts:82
    // assert(mbrPay.amount === Global.assetOptInMinBalance);
    frame_dig -2
    gtxns Amount
    global AssetOptInMinBalance
    ==
    assert
    // contracts/marketplace/marketplace.algo.ts:84-90
    // itxn
    //   .assetTransfer({
    //     xferAsset: asset,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //   })
    //   .submit();
    itxn_begin
    // contracts/marketplace/marketplace.algo.ts:87
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // contracts/marketplace/marketplace.algo.ts:88
    // assetAmount: 0,
    intc_1 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    frame_dig -1
    itxn_field XferAsset
    // contracts/marketplace/marketplace.algo.ts:84-89
    // itxn
    //   .assetTransfer({
    //     xferAsset: asset,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    // contracts/marketplace/marketplace.algo.ts:84-90
    // itxn
    //   .assetTransfer({
    //     xferAsset: asset,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //   })
    //   .submit();
    itxn_submit
    retsub


// contracts/marketplace/marketplace.algo.ts::DigitalMarketplace.firstDeposit(mbrPay: uint64, xfer: uint64, unitaryPrice: bytes, nonce: bytes) -> void:
firstDeposit:
    // contracts/marketplace/marketplace.algo.ts:93-99
    // @arc4.abimethod()
    // firstDeposit(
    //   mbrPay: gtxn.PaymentTxn,
    //   xfer: gtxn.AssetTransferTxn,
    //   unitaryPrice: arc4.UintN64,
    //   nonce: arc4.UintN64,
    // ) {
    proto 4 0
    // contracts/marketplace/marketplace.algo.ts:100
    // assert(mbrPay.sender === Txn.sender);
    frame_dig -4
    gtxns Sender
    txn Sender
    ==
    assert
    // contracts/marketplace/marketplace.algo.ts:101
    // assert(mbrPay.receiver === Global.currentApplicationAddress);
    frame_dig -4
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert
    // contracts/marketplace/marketplace.algo.ts:102
    // assert(mbrPay.amount === this.listingsBoxMbr());
    frame_dig -4
    gtxns Amount
    // contracts/marketplace/marketplace.algo.ts:35-49
    // 2_500 +
    // // fmt: off
    // // Key length
    // (8 +
    //   32 +
    //   8 +
    //   8 +
    //   // Value length
    //   8 +
    //   8 +
    //   32 +
    //   8 +
    //   8) *
    //   // fmt: on
    //   400
    intc 4 // 50500
    // contracts/marketplace/marketplace.algo.ts:102
    // assert(mbrPay.amount === this.listingsBoxMbr());
    ==
    assert
    // contracts/marketplace/marketplace.algo.ts:105
    // owner: new arc4.Address(Txn.sender),
    txn Sender
    // contracts/marketplace/marketplace.algo.ts:106
    // asset: new arc4.UintN64(xfer.xferAsset.id),
    frame_dig -3
    gtxns XferAsset
    itob
    // contracts/marketplace/marketplace.algo.ts:104-108
    // const key = new ListingKey({
    //   owner: new arc4.Address(Txn.sender),
    //   asset: new arc4.UintN64(xfer.xferAsset.id),
    //   nonce: nonce,
    // });
    concat
    frame_dig -1
    concat
    // contracts/marketplace/marketplace.algo.ts:31
    // listings = BoxMap<ListingKey, ListingValue>({ keyPrefix: "listings" });
    bytec_0 // "listings"
    swap
    concat
    // contracts/marketplace/marketplace.algo.ts:109
    // assert(!this.listings(key).exists);
    dup
    box_len
    bury 1
    !
    assert
    // contracts/marketplace/marketplace.algo.ts:111
    // assert(xfer.sender === Txn.sender);
    frame_dig -3
    gtxns Sender
    txn Sender
    ==
    assert
    // contracts/marketplace/marketplace.algo.ts:112
    // assert(xfer.assetReceiver === Global.currentApplicationAddress);
    frame_dig -3
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    assert
    // contracts/marketplace/marketplace.algo.ts:113
    // assert(xfer.assetAmount > 0);
    frame_dig -3
    gtxns AssetAmount
    dup
    assert
    // contracts/marketplace/marketplace.algo.ts:116
    // deposited: new arc4.UintN64(xfer.assetAmount),
    itob
    // contracts/marketplace/marketplace.algo.ts:115-121
    // this.listings(key).value = new ListingValue({
    //   deposited: new arc4.UintN64(xfer.assetAmount),
    //   unitaryPrice: unitaryPrice,
    //   bidder: new arc4.Address(),
    //   bid: new arc4.UintN64(),
    //   bidUnitaryPrice: new arc4.UintN64(),
    // });
    frame_dig -2
    concat
    // contracts/marketplace/marketplace.algo.ts:118
    // bidder: new arc4.Address(),
    bytec_1 // addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
    // contracts/marketplace/marketplace.algo.ts:115-121
    // this.listings(key).value = new ListingValue({
    //   deposited: new arc4.UintN64(xfer.assetAmount),
    //   unitaryPrice: unitaryPrice,
    //   bidder: new arc4.Address(),
    //   bid: new arc4.UintN64(),
    //   bidUnitaryPrice: new arc4.UintN64(),
    // });
    concat
    // contracts/marketplace/marketplace.algo.ts:119
    // bid: new arc4.UintN64(),
    bytec_3 // 0x0000000000000000
    // contracts/marketplace/marketplace.algo.ts:115-121
    // this.listings(key).value = new ListingValue({
    //   deposited: new arc4.UintN64(xfer.assetAmount),
    //   unitaryPrice: unitaryPrice,
    //   bidder: new arc4.Address(),
    //   bid: new arc4.UintN64(),
    //   bidUnitaryPrice: new arc4.UintN64(),
    // });
    concat
    // contracts/marketplace/marketplace.algo.ts:120
    // bidUnitaryPrice: new arc4.UintN64(),
    bytec_3 // 0x0000000000000000
    // contracts/marketplace/marketplace.algo.ts:115-121
    // this.listings(key).value = new ListingValue({
    //   deposited: new arc4.UintN64(xfer.assetAmount),
    //   unitaryPrice: unitaryPrice,
    //   bidder: new arc4.Address(),
    //   bid: new arc4.UintN64(),
    //   bidUnitaryPrice: new arc4.UintN64(),
    // });
    concat
    box_put
    retsub


// contracts/marketplace/marketplace.algo.ts::DigitalMarketplace.deposit(xfer: uint64, nonce: bytes) -> void:
deposit:
    // contracts/marketplace/marketplace.algo.ts:124-125
    // @arc4.abimethod()
    // deposit(xfer: gtxn.AssetTransferTxn, nonce: arc4.UintN64) {
    proto 2 0
    // contracts/marketplace/marketplace.algo.ts:127
    // owner: new arc4.Address(Txn.sender),
    txn Sender
    // contracts/marketplace/marketplace.algo.ts:128
    // asset: new arc4.UintN64(xfer.xferAsset.id),
    frame_dig -2
    gtxns XferAsset
    itob
    // contracts/marketplace/marketplace.algo.ts:126-130
    // const key = new ListingKey({
    //   owner: new arc4.Address(Txn.sender),
    //   asset: new arc4.UintN64(xfer.xferAsset.id),
    //   nonce: nonce,
    // });
    concat
    frame_dig -1
    concat
    // contracts/marketplace/marketplace.algo.ts:132
    // assert(xfer.sender === Txn.sender);
    frame_dig -2
    gtxns Sender
    txn Sender
    ==
    assert
    // contracts/marketplace/marketplace.algo.ts:133
    // assert(xfer.assetReceiver === Global.currentApplicationAddress);
    frame_dig -2
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    assert
    // contracts/marketplace/marketplace.algo.ts:134
    // assert(xfer.assetAmount > 0);
    frame_dig -2
    gtxns AssetAmount
    dup
    assert
    // contracts/marketplace/marketplace.algo.ts:31
    // listings = BoxMap<ListingKey, ListingValue>({ keyPrefix: "listings" });
    bytec_0 // "listings"
    uncover 2
    concat
    // contracts/marketplace/marketplace.algo.ts:136
    // const existing = this.listings(key).value.copy();
    dup
    box_get
    assert // Box must have value
    // contracts/marketplace/marketplace.algo.ts:138
    // bid: existing.bid,
    dup
    extract 48 8 // on error: Index access is out of bounds
    // contracts/marketplace/marketplace.algo.ts:139
    // bidUnitaryPrice: existing.bidUnitaryPrice,
    dig 1
    extract 56 8 // on error: Index access is out of bounds
    // contracts/marketplace/marketplace.algo.ts:140
    // bidder: existing.bidder,
    dig 2
    extract 16 32 // on error: Index access is out of bounds
    // contracts/marketplace/marketplace.algo.ts:141
    // unitaryPrice: existing.unitaryPrice,
    dig 3
    extract 8 8 // on error: Index access is out of bounds
    // contracts/marketplace/marketplace.algo.ts:142
    // deposited: new arc4.UintN64(existing.deposited.native + xfer.assetAmount),
    uncover 4
    intc_1 // 0
    extract_uint64
    uncover 6
    +
    itob
    // contracts/marketplace/marketplace.algo.ts:137-143
    // this.listings(key).value = new ListingValue({
    //   bid: existing.bid,
    //   bidUnitaryPrice: existing.bidUnitaryPrice,
    //   bidder: existing.bidder,
    //   unitaryPrice: existing.unitaryPrice,
    //   deposited: new arc4.UintN64(existing.deposited.native + xfer.assetAmount),
    // });
    swap
    concat
    swap
    concat
    uncover 2
    concat
    swap
    concat
    box_put
    retsub


// contracts/marketplace/marketplace.algo.ts::DigitalMarketplace.setPrice(asset: uint64, nonce: bytes, unitaryPrice: bytes) -> void:
setPrice:
    // contracts/marketplace/marketplace.algo.ts:146-147
    // @arc4.abimethod()
    // setPrice(asset: Asset, nonce: arc4.UintN64, unitaryPrice: arc4.UintN64) {
    proto 3 0
    // contracts/marketplace/marketplace.algo.ts:149
    // owner: new arc4.Address(Txn.sender),
    txn Sender
    // contracts/marketplace/marketplace.algo.ts:150
    // asset: new arc4.UintN64(asset.id),
    frame_dig -3
    itob
    // contracts/marketplace/marketplace.algo.ts:148-152
    // const key = new ListingKey({
    //   owner: new arc4.Address(Txn.sender),
    //   asset: new arc4.UintN64(asset.id),
    //   nonce: nonce,
    // });
    concat
    frame_dig -2
    concat
    // contracts/marketplace/marketplace.algo.ts:31
    // listings = BoxMap<ListingKey, ListingValue>({ keyPrefix: "listings" });
    bytec_0 // "listings"
    swap
    concat
    // contracts/marketplace/marketplace.algo.ts:154
    // const existing = this.listings(key).value.copy();
    dup
    box_get
    assert // Box must have value
    // contracts/marketplace/marketplace.algo.ts:156
    // bid: existing.bid,
    dup
    extract 48 8 // on error: Index access is out of bounds
    // contracts/marketplace/marketplace.algo.ts:157
    // bidUnitaryPrice: existing.bidUnitaryPrice,
    dig 1
    extract 56 8 // on error: Index access is out of bounds
    // contracts/marketplace/marketplace.algo.ts:158
    // bidder: existing.bidder,
    dig 2
    extract 16 32 // on error: Index access is out of bounds
    // contracts/marketplace/marketplace.algo.ts:159
    // deposited: existing.deposited,
    uncover 3
    extract 0 8 // on error: Index access is out of bounds
    // contracts/marketplace/marketplace.algo.ts:155-161
    // this.listings(key).value = new ListingValue({
    //   bid: existing.bid,
    //   bidUnitaryPrice: existing.bidUnitaryPrice,
    //   bidder: existing.bidder,
    //   deposited: existing.deposited,
    //   unitaryPrice: unitaryPrice,
    // });
    frame_dig -1
    concat
    swap
    concat
    uncover 2
    concat
    swap
    concat
    box_put
    retsub


// contracts/marketplace/marketplace.algo.ts::DigitalMarketplace.buy(owner: bytes, asset: uint64, nonce: bytes, buyPay: uint64, quantity: uint64) -> void:
buy:
    // contracts/marketplace/marketplace.algo.ts:164-171
    // @arc4.abimethod()
    // buy(
    //   owner: arc4.Address,
    //   asset: Asset,
    //   nonce: arc4.UintN64,
    //   buyPay: gtxn.PaymentTxn,
    //   quantity: uint64,
    // ) {
    proto 5 0
    // contracts/marketplace/marketplace.algo.ts:174
    // asset: new arc4.UintN64(asset.id),
    frame_dig -4
    itob
    // contracts/marketplace/marketplace.algo.ts:172-176
    // const key = new ListingKey({
    //   owner: owner,
    //   asset: new arc4.UintN64(asset.id),
    //   nonce: nonce,
    // });
    frame_dig -5
    swap
    concat
    frame_dig -3
    concat
    // contracts/marketplace/marketplace.algo.ts:31
    // listings = BoxMap<ListingKey, ListingValue>({ keyPrefix: "listings" });
    bytec_0 // "listings"
    swap
    concat
    // contracts/marketplace/marketplace.algo.ts:178
    // const listing = this.listings(key).value.copy();
    dup
    box_get
    assert // Box must have value
    // contracts/marketplace/marketplace.algo.ts:182
    // listing.unitaryPrice.native,
    dup
    extract 8 8 // on error: Index access is out of bounds
    dig 1
    pushint 8 // 8
    extract_uint64
    // contracts/marketplace/marketplace.algo.ts:183
    // asset.decimals,
    frame_dig -4
    asset_params_get AssetDecimals
    assert // asset exists
    // contracts/marketplace/marketplace.algo.ts:180-184
    // const amountToBePaid = this.quantityPrice(
    //   quantity,
    //   listing.unitaryPrice.native,
    //   asset.decimals,
    // );
    frame_dig -1
    cover 2
    callsub quantityPrice
    // contracts/marketplace/marketplace.algo.ts:186
    // assert(buyPay.sender === Txn.sender);
    frame_dig -2
    gtxns Sender
    txn Sender
    ==
    assert
    // contracts/marketplace/marketplace.algo.ts:187
    // assert(buyPay.receiver.bytes === owner.bytes);
    frame_dig -2
    gtxns Receiver
    frame_dig -5
    ==
    assert
    // contracts/marketplace/marketplace.algo.ts:188
    // assert(buyPay.amount === amountToBePaid);
    frame_dig -2
    gtxns Amount
    ==
    assert
    // contracts/marketplace/marketplace.algo.ts:191
    // bid: listing.bid,
    dig 1
    extract 48 8 // on error: Index access is out of bounds
    // contracts/marketplace/marketplace.algo.ts:192
    // bidUnitaryPrice: listing.bidUnitaryPrice,
    dig 2
    extract 56 8 // on error: Index access is out of bounds
    // contracts/marketplace/marketplace.algo.ts:193
    // bidder: listing.bidder,
    dig 3
    extract 16 32 // on error: Index access is out of bounds
    // contracts/marketplace/marketplace.algo.ts:195
    // deposited: new arc4.UintN64(listing.deposited.native - quantity),
    uncover 4
    intc_1 // 0
    extract_uint64
    frame_dig -1
    -
    itob
    // contracts/marketplace/marketplace.algo.ts:190-196
    // this.listings(key).value = new ListingValue({
    //   bid: listing.bid,
    //   bidUnitaryPrice: listing.bidUnitaryPrice,
    //   bidder: listing.bidder,
    //   unitaryPrice: listing.unitaryPrice,
    //   deposited: new arc4.UintN64(listing.deposited.native - quantity),
    // });
    uncover 4
    concat
    swap
    concat
    uncover 2
    concat
    swap
    concat
    box_put
    // contracts/marketplace/marketplace.algo.ts:198-204
    // itxn
    //   .assetTransfer({
    //     xferAsset: asset,
    //     assetReceiver: Txn.sender,
    //     assetAmount: quantity,
    //   })
    //   .submit();
    itxn_begin
    // contracts/marketplace/marketplace.algo.ts:201
    // assetReceiver: Txn.sender,
    txn Sender
    frame_dig -1
    itxn_field AssetAmount
    itxn_field AssetReceiver
    frame_dig -4
    itxn_field XferAsset
    // contracts/marketplace/marketplace.algo.ts:198-203
    // itxn
    //   .assetTransfer({
    //     xferAsset: asset,
    //     assetReceiver: Txn.sender,
    //     assetAmount: quantity,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    // contracts/marketplace/marketplace.algo.ts:198-204
    // itxn
    //   .assetTransfer({
    //     xferAsset: asset,
    //     assetReceiver: Txn.sender,
    //     assetAmount: quantity,
    //   })
    //   .submit();
    itxn_submit
    retsub


// contracts/marketplace/marketplace.algo.ts::DigitalMarketplace.withdraw(asset: uint64, nonce: bytes) -> void:
withdraw:
    // contracts/marketplace/marketplace.algo.ts:207-208
    // @arc4.abimethod()
    // withdraw(asset: Asset, nonce: arc4.UintN64) {
    proto 2 0
    // contracts/marketplace/marketplace.algo.ts:210
    // owner: new arc4.Address(Txn.sender),
    txn Sender
    // contracts/marketplace/marketplace.algo.ts:211
    // asset: new arc4.UintN64(asset.id),
    frame_dig -2
    itob
    // contracts/marketplace/marketplace.algo.ts:209-213
    // const key = new ListingKey({
    //   owner: new arc4.Address(Txn.sender),
    //   asset: new arc4.UintN64(asset.id),
    //   nonce: nonce,
    // });
    concat
    frame_dig -1
    concat
    // contracts/marketplace/marketplace.algo.ts:31
    // listings = BoxMap<ListingKey, ListingValue>({ keyPrefix: "listings" });
    bytec_0 // "listings"
    swap
    concat
    dup
    // contracts/marketplace/marketplace.algo.ts:215
    // const listing = this.listings(key).value.copy();
    box_get
    swap
    dup
    uncover 2
    assert // Box must have value
    // contracts/marketplace/marketplace.algo.ts:216
    // if (listing.bidder !== new arc4.Address()) {
    extract 16 32 // on error: Index access is out of bounds
    dup
    bytec_1 // addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
    !=
    bz withdraw_after_if_else@3
    // contracts/marketplace/marketplace.algo.ts:218
    // listing.bid.native,
    frame_dig 1
    dup
    intc_3 // 48
    extract_uint64
    // contracts/marketplace/marketplace.algo.ts:219
    // listing.bidUnitaryPrice.native,
    swap
    pushint 56 // 56
    extract_uint64
    // contracts/marketplace/marketplace.algo.ts:220
    // asset.decimals,
    frame_dig -2
    asset_params_get AssetDecimals
    assert // asset exists
    // contracts/marketplace/marketplace.algo.ts:217-221
    // const currentBidDeposit = this.quantityPrice(
    //   listing.bid.native,
    //   listing.bidUnitaryPrice.native,
    //   asset.decimals,
    // );
    callsub quantityPrice
    // contracts/marketplace/marketplace.algo.ts:222-224
    // itxn
    //   .payment({ receiver: listing.bidder.native, amount: currentBidDeposit })
    //   .submit();
    itxn_begin
    itxn_field Amount
    frame_dig 2
    itxn_field Receiver
    // contracts/marketplace/marketplace.algo.ts:222-223
    // itxn
    //   .payment({ receiver: listing.bidder.native, amount: currentBidDeposit })
    intc_0 // 1
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    // contracts/marketplace/marketplace.algo.ts:222-224
    // itxn
    //   .payment({ receiver: listing.bidder.native, amount: currentBidDeposit })
    //   .submit();
    itxn_submit

withdraw_after_if_else@3:
    // contracts/marketplace/marketplace.algo.ts:227
    // this.listings(key).delete();
    frame_dig 0
    box_del
    pop
    // contracts/marketplace/marketplace.algo.ts:229-231
    // itxn
    //   .payment({ receiver: Txn.sender, amount: this.listingsBoxMbr() })
    //   .submit();
    itxn_begin
    // contracts/marketplace/marketplace.algo.ts:230
    // .payment({ receiver: Txn.sender, amount: this.listingsBoxMbr() })
    txn Sender
    // contracts/marketplace/marketplace.algo.ts:35-49
    // 2_500 +
    // // fmt: off
    // // Key length
    // (8 +
    //   32 +
    //   8 +
    //   8 +
    //   // Value length
    //   8 +
    //   8 +
    //   32 +
    //   8 +
    //   8) *
    //   // fmt: on
    //   400
    intc 4 // 50500
    itxn_field Amount
    itxn_field Receiver
    // contracts/marketplace/marketplace.algo.ts:229-230
    // itxn
    //   .payment({ receiver: Txn.sender, amount: this.listingsBoxMbr() })
    intc_0 // 1
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    // contracts/marketplace/marketplace.algo.ts:229-231
    // itxn
    //   .payment({ receiver: Txn.sender, amount: this.listingsBoxMbr() })
    //   .submit();
    itxn_submit
    // contracts/marketplace/marketplace.algo.ts:233-239
    // itxn
    //   .assetTransfer({
    //     xferAsset: asset,
    //     assetReceiver: Txn.sender,
    //     assetAmount: listing.deposited.native,
    //   })
    //   .submit();
    itxn_begin
    // contracts/marketplace/marketplace.algo.ts:236
    // assetReceiver: Txn.sender,
    txn Sender
    // contracts/marketplace/marketplace.algo.ts:237
    // assetAmount: listing.deposited.native,
    frame_dig 1
    intc_1 // 0
    extract_uint64
    itxn_field AssetAmount
    itxn_field AssetReceiver
    frame_dig -2
    itxn_field XferAsset
    // contracts/marketplace/marketplace.algo.ts:233-238
    // itxn
    //   .assetTransfer({
    //     xferAsset: asset,
    //     assetReceiver: Txn.sender,
    //     assetAmount: listing.deposited.native,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    // contracts/marketplace/marketplace.algo.ts:233-239
    // itxn
    //   .assetTransfer({
    //     xferAsset: asset,
    //     assetReceiver: Txn.sender,
    //     assetAmount: listing.deposited.native,
    //   })
    //   .submit();
    itxn_submit
    retsub


// contracts/marketplace/marketplace.algo.ts::DigitalMarketplace.bid(owner: bytes, asset: uint64, nonce: bytes, bidPay: uint64, quantity: bytes, unitaryPrice: bytes) -> void:
bid:
    // contracts/marketplace/marketplace.algo.ts:242-250
    // @arc4.abimethod()
    // bid(
    //   owner: arc4.Address,
    //   asset: Asset,
    //   nonce: arc4.UintN64,
    //   bidPay: gtxn.PaymentTxn,
    //   quantity: arc4.UintN64,
    //   unitaryPrice: arc4.UintN64,
    // ) {
    proto 6 0
    // contracts/marketplace/marketplace.algo.ts:253
    // asset: new arc4.UintN64(asset.id),
    frame_dig -5
    itob
    // contracts/marketplace/marketplace.algo.ts:251-255
    // const key = new ListingKey({
    //   owner,
    //   asset: new arc4.UintN64(asset.id),
    //   nonce,
    // });
    frame_dig -6
    swap
    concat
    frame_dig -4
    concat
    // contracts/marketplace/marketplace.algo.ts:31
    // listings = BoxMap<ListingKey, ListingValue>({ keyPrefix: "listings" });
    bytec_0 // "listings"
    swap
    concat
    dup
    // contracts/marketplace/marketplace.algo.ts:257
    // const listing = this.listings(key).value.copy();
    box_get
    swap
    dup
    uncover 2
    assert // Box must have value
    // contracts/marketplace/marketplace.algo.ts:258
    // if (listing.bidder !== new arc4.Address()) {
    extract 16 32 // on error: Index access is out of bounds
    dup
    bytec_1 // addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
    !=
    bz bid_after_if_else@3
    // contracts/marketplace/marketplace.algo.ts:259
    // assert(unitaryPrice.native > listing.bidUnitaryPrice.native);
    frame_dig -1
    btoi
    frame_dig 1
    dup
    cover 2
    pushint 56 // 56
    extract_uint64
    swap
    dig 1
    >
    assert
    // contracts/marketplace/marketplace.algo.ts:262
    // listing.bid.native,
    swap
    intc_3 // 48
    extract_uint64
    // contracts/marketplace/marketplace.algo.ts:264
    // asset.decimals,
    frame_dig -5
    asset_params_get AssetDecimals
    assert // asset exists
    // contracts/marketplace/marketplace.algo.ts:261-265
    // const currentBidAmount = this.quantityPrice(
    //   listing.bid.native,
    //   listing.bidUnitaryPrice.native,
    //   asset.decimals,
    // );
    swap
    cover 2
    callsub quantityPrice
    // contracts/marketplace/marketplace.algo.ts:267-269
    // itxn
    //   .payment({ receiver: listing.bidder.native, amount: currentBidAmount })
    //   .submit();
    itxn_begin
    itxn_field Amount
    frame_dig 2
    itxn_field Receiver
    // contracts/marketplace/marketplace.algo.ts:267-268
    // itxn
    //   .payment({ receiver: listing.bidder.native, amount: currentBidAmount })
    intc_0 // 1
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    // contracts/marketplace/marketplace.algo.ts:267-269
    // itxn
    //   .payment({ receiver: listing.bidder.native, amount: currentBidAmount })
    //   .submit();
    itxn_submit

bid_after_if_else@3:
    // contracts/marketplace/marketplace.algo.ts:273
    // quantity.native,
    frame_dig -2
    btoi
    // contracts/marketplace/marketplace.algo.ts:274
    // unitaryPrice.native,
    frame_dig -1
    btoi
    // contracts/marketplace/marketplace.algo.ts:275
    // asset.decimals,
    frame_dig -5
    asset_params_get AssetDecimals
    assert // asset exists
    // contracts/marketplace/marketplace.algo.ts:272-276
    // const amountToBeBid = this.quantityPrice(
    //   quantity.native,
    //   unitaryPrice.native,
    //   asset.decimals,
    // );
    callsub quantityPrice
    // contracts/marketplace/marketplace.algo.ts:278
    // assert(bidPay.sender === Txn.sender);
    frame_dig -3
    gtxns Sender
    txn Sender
    ==
    assert
    // contracts/marketplace/marketplace.algo.ts:279
    // assert(bidPay.receiver === Global.currentApplicationAddress);
    frame_dig -3
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert
    // contracts/marketplace/marketplace.algo.ts:280
    // assert(bidPay.amount === amountToBeBid);
    frame_dig -3
    gtxns Amount
    ==
    assert
    // contracts/marketplace/marketplace.algo.ts:283
    // deposited: listing.deposited,
    frame_dig 1
    dup
    extract 0 8 // on error: Index access is out of bounds
    // contracts/marketplace/marketplace.algo.ts:284
    // unitaryPrice: listing.unitaryPrice,
    swap
    extract 8 8 // on error: Index access is out of bounds
    // contracts/marketplace/marketplace.algo.ts:285
    // bidder: new arc4.Address(Txn.sender),
    txn Sender
    // contracts/marketplace/marketplace.algo.ts:282-288
    // this.listings(key).value = new ListingValue({
    //   deposited: listing.deposited,
    //   unitaryPrice: listing.unitaryPrice,
    //   bidder: new arc4.Address(Txn.sender),
    //   bid: quantity,
    //   bidUnitaryPrice: unitaryPrice,
    // });
    cover 2
    concat
    swap
    concat
    frame_dig -2
    concat
    frame_dig -1
    concat
    frame_dig 0
    swap
    box_put
    retsub


// contracts/marketplace/marketplace.algo.ts::DigitalMarketplace.acceptBid(asset: uint64, nonce: bytes) -> void:
acceptBid:
    // contracts/marketplace/marketplace.algo.ts:291-292
    // @arc4.abimethod()
    // acceptBid(asset: Asset, nonce: arc4.UintN64) {
    proto 2 0
    // contracts/marketplace/marketplace.algo.ts:294
    // owner: new arc4.Address(Txn.sender),
    txn Sender
    // contracts/marketplace/marketplace.algo.ts:295
    // asset: new arc4.UintN64(asset.id),
    frame_dig -2
    itob
    // contracts/marketplace/marketplace.algo.ts:293-297
    // const key = new ListingKey({
    //   owner: new arc4.Address(Txn.sender),
    //   asset: new arc4.UintN64(asset.id),
    //   nonce,
    // });
    concat
    frame_dig -1
    concat
    // contracts/marketplace/marketplace.algo.ts:31
    // listings = BoxMap<ListingKey, ListingValue>({ keyPrefix: "listings" });
    bytec_0 // "listings"
    swap
    concat
    dup
    // contracts/marketplace/marketplace.algo.ts:299
    // const listing = this.listings(key).value.copy();
    box_get
    swap
    dup
    uncover 2
    assert // Box must have value
    // contracts/marketplace/marketplace.algo.ts:300
    // assert(listing.bidder !== new arc4.Address());
    dup
    extract 16 32 // on error: Index access is out of bounds
    dup
    cover 2
    bytec_1 // addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
    !=
    assert
    // contracts/marketplace/marketplace.algo.ts:303
    // listing.deposited.native < listing.bid.native
    dup
    intc_1 // 0
    extract_uint64
    dup
    uncover 2
    intc_3 // 48
    extract_uint64
    dup
    cover 2
    <
    // contracts/marketplace/marketplace.algo.ts:303-305
    // listing.deposited.native < listing.bid.native
    //   ? listing.deposited.native
    //   : listing.bid.native;
    bz acceptBid_ternary_false@2
    frame_dig 3

acceptBid_ternary_merge@3:
    // contracts/marketplace/marketplace.algo.ts:309
    // listing.bidUnitaryPrice.native,
    frame_dig 1
    dup
    extract 56 8 // on error: Index access is out of bounds
    dig 1
    pushint 56 // 56
    extract_uint64
    // contracts/marketplace/marketplace.algo.ts:310
    // asset.decimals,
    frame_dig -2
    asset_params_get AssetDecimals
    assert // asset exists
    // contracts/marketplace/marketplace.algo.ts:307-311
    // const bestBidAmount = this.quantityPrice(
    //   minQuantity,
    //   listing.bidUnitaryPrice.native,
    //   asset.decimals,
    // );
    uncover 4
    dup
    cover 3
    cover 2
    callsub quantityPrice
    // contracts/marketplace/marketplace.algo.ts:313
    // itxn.payment({ receiver: Txn.sender, amount: bestBidAmount }).submit();
    itxn_begin
    txn Sender
    itxn_field Receiver
    itxn_field Amount
    intc_0 // 1
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    itxn_submit
    // contracts/marketplace/marketplace.algo.ts:315-321
    // itxn
    //   .assetTransfer({
    //     xferAsset: asset,
    //     assetReceiver: listing.bidder.native,
    //     assetAmount: minQuantity,
    //   })
    //   .submit();
    itxn_begin
    dup
    itxn_field AssetAmount
    frame_dig 2
    dup
    cover 2
    itxn_field AssetReceiver
    frame_dig -2
    itxn_field XferAsset
    // contracts/marketplace/marketplace.algo.ts:315-320
    // itxn
    //   .assetTransfer({
    //     xferAsset: asset,
    //     assetReceiver: listing.bidder.native,
    //     assetAmount: minQuantity,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    // contracts/marketplace/marketplace.algo.ts:315-321
    // itxn
    //   .assetTransfer({
    //     xferAsset: asset,
    //     assetReceiver: listing.bidder.native,
    //     assetAmount: minQuantity,
    //   })
    //   .submit();
    itxn_submit
    // contracts/marketplace/marketplace.algo.ts:326
    // unitaryPrice: listing.unitaryPrice,
    uncover 3
    extract 8 8 // on error: Index access is out of bounds
    // contracts/marketplace/marketplace.algo.ts:327
    // deposited: new arc4.UintN64(listing.deposited.native - minQuantity),
    frame_dig 3
    dig 2
    -
    itob
    // contracts/marketplace/marketplace.algo.ts:328
    // bid: new arc4.UintN64(listing.bid.native - minQuantity),
    frame_dig 4
    uncover 3
    -
    itob
    // contracts/marketplace/marketplace.algo.ts:323-329
    // this.listings(key).value = new ListingValue({
    //   bidder: listing.bidder,
    //   bidUnitaryPrice: listing.bidUnitaryPrice,
    //   unitaryPrice: listing.unitaryPrice,
    //   deposited: new arc4.UintN64(listing.deposited.native - minQuantity),
    //   bid: new arc4.UintN64(listing.bid.native - minQuantity),
    // });
    swap
    uncover 2
    concat
    uncover 2
    concat
    swap
    concat
    swap
    concat
    frame_dig 0
    swap
    box_put
    retsub

acceptBid_ternary_false@2:
    frame_dig 4
    b acceptBid_ternary_merge@3

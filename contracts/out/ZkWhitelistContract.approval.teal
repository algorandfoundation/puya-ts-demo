#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 1 0 6 32 TMPL_VERIFIER_APP_ID
    bytecblock 0x151f7c75 0x068101 "whiteList"
    // contracts/zk-whitelist.algo.ts:26
    // export default class ZkWhitelistContract extends arc4.Contract {
    txn NumAppArgs
    bz main_after_if_else@12
    pushbytess 0x20df3a54 0xa0e81872 0x9300aae2 0xcb77c07a 0x517637c6 0xf10773f1 // method "create(string)void", method "update()void", method "optInOrOut()void", method "addAddressToWhitelist(address,address[])string", method "isOnWhitelist(address)bool", method "verifyProof(uint64,address[],address[])bool"
    txna ApplicationArgs 0
    match main_create_route@3 main_update_route@4 main_optInOrOut_route@5 main_addAddressToWhitelist_route@6 main_isOnWhitelist_route@7 main_verifyProof_route@8

main_after_if_else@12:
    // contracts/zk-whitelist.algo.ts:26
    // export default class ZkWhitelistContract extends arc4.Contract {
    intc_1 // 0
    return

main_verifyProof_route@8:
    // contracts/zk-whitelist.algo.ts:91-95
    // verifyProof(
    //   appId: uint64,
    //   proof: arc4.Address[],
    //   publicInputs: arc4.Address[],
    // ): arc4.Bool {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/zk-whitelist.algo.ts:26
    // export default class ZkWhitelistContract extends arc4.Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // contracts/zk-whitelist.algo.ts:91-95
    // verifyProof(
    //   appId: uint64,
    //   proof: arc4.Address[],
    //   publicInputs: arc4.Address[],
    // ): arc4.Bool {
    callsub verifyProof
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_isOnWhitelist_route@7:
    // contracts/zk-whitelist.algo.ts:80
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/zk-whitelist.algo.ts:26
    // export default class ZkWhitelistContract extends arc4.Contract {
    txna ApplicationArgs 1
    // contracts/zk-whitelist.algo.ts:80
    // @abimethod()
    callsub isOnWhitelist
    pushbytes 0x00
    intc_1 // 0
    uncover 2
    setbit
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_addAddressToWhitelist_route@6:
    // contracts/zk-whitelist.algo.ts:48
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/zk-whitelist.algo.ts:26
    // export default class ZkWhitelistContract extends arc4.Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // contracts/zk-whitelist.algo.ts:48
    // @abimethod()
    callsub addAddressToWhitelist
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_optInOrOut_route@5:
    // contracts/zk-whitelist.algo.ts:42
    // @abimethod({ allowActions: ["OptIn", "CloseOut"] })
    intc_0 // 1
    txn OnCompletion
    shl
    intc_2 // 6
    &
    assert // OnCompletion is not one of OptIn, CloseOut
    txn ApplicationID
    assert // can only call when not creating
    intc_0 // 1
    return

main_update_route@4:
    // contracts/zk-whitelist.algo.ts:36
    // @abimethod({ allowActions: ["UpdateApplication", "DeleteApplication"] })
    intc_0 // 1
    txn OnCompletion
    shl
    pushint 48 // 48
    &
    assert // OnCompletion is not one of UpdateApplication, DeleteApplication
    txn ApplicationID
    assert // can only call when not creating
    callsub update
    intc_0 // 1
    return

main_create_route@3:
    // contracts/zk-whitelist.algo.ts:30
    // @abimethod({ onCreate: "require" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // contracts/zk-whitelist.algo.ts:26
    // export default class ZkWhitelistContract extends arc4.Contract {
    txna ApplicationArgs 1
    extract 2 0
    // contracts/zk-whitelist.algo.ts:30
    // @abimethod({ onCreate: "require" })
    callsub create
    intc_0 // 1
    return


// contracts/zk-whitelist.algo.ts::ZkWhitelistContract.create(name: bytes) -> void:
create:
    // contracts/zk-whitelist.algo.ts:30-31
    // @abimethod({ onCreate: "require" })
    // create(name: string) {
    proto 1 0
    // contracts/zk-whitelist.algo.ts:27
    // appName = GlobalState<string>({});
    pushbytes "appName"
    // contracts/zk-whitelist.algo.ts:33
    // this.appName.value = name;
    frame_dig -1
    app_global_put
    retsub


// contracts/zk-whitelist.algo.ts::ZkWhitelistContract.update() -> void:
update:
    // contracts/zk-whitelist.algo.ts:39
    // assert(Global.creatorAddress === Txn.sender);
    global CreatorAddress
    txn Sender
    ==
    assert
    retsub


// contracts/zk-whitelist.algo.ts::ZkWhitelistContract.addAddressToWhitelist(address: bytes, proof: bytes) -> bytes:
addAddressToWhitelist:
    // contracts/zk-whitelist.algo.ts:48-49
    // @abimethod()
    // addAddressToWhitelist(address: arc4.Address, proof: arc4.Address[]): string {
    proto 2 1

addAddressToWhitelist_while_top@6:
    pushint 145010 // 145010
    global OpcodeBudget
    >
    bz addAddressToWhitelist_after_while@11
    itxn_begin
    intc_2 // appl
    itxn_field TypeEnum
    pushint 5 // DeleteApplication
    itxn_field OnCompletion
    bytec_1 // 0x068101
    itxn_field ApprovalProgram
    bytec_1 // 0x068101
    itxn_field ClearStateProgram
    intc_1 // 0
    itxn_field Fee
    itxn_submit
    b addAddressToWhitelist_while_top@6

addAddressToWhitelist_after_while@11:
    // contracts/zk-whitelist.algo.ts:60
    // op.bzero(32).bitwiseOr(Bytes(BigUint(address.bytes) % curveMod)),
    intc_3 // 32
    bzero
    frame_dig -2
    // contracts/zk-whitelist.algo.ts:22
    // 21888242871839275222246405745257275088548364400416034343698204186575808495617n,
    pushbytes 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001
    // contracts/zk-whitelist.algo.ts:60
    // op.bzero(32).bitwiseOr(Bytes(BigUint(address.bytes) % curveMod)),
    b%
    b|
    // contracts/zk-whitelist.algo.ts:66
    // [addressMod],
    dup
    len
    intc_3 // 32
    /
    itob
    extract 6 2
    swap
    concat
    // contracts/zk-whitelist.algo.ts:64
    // TemplateVar<uint64>("VERIFIER_APP_ID"),
    intc 4 // TMPL_VERIFIER_APP_ID
    // contracts/zk-whitelist.algo.ts:63-67
    // const verified = this.verifyProof(
    //   TemplateVar<uint64>("VERIFIER_APP_ID"),
    //   proof,
    //   [addressMod],
    // );
    frame_dig -1
    uncover 2
    callsub verifyProof
    intc_1 // 0
    // contracts/zk-whitelist.algo.ts:68
    // if (!verified.native) {
    getbit
    bnz addAddressToWhitelist_after_if_else@2
    // contracts/zk-whitelist.algo.ts:69
    // return "Proof verification failed";
    pushbytes "Proof verification failed"
    retsub

addAddressToWhitelist_after_if_else@2:
    // contracts/zk-whitelist.algo.ts:73
    // if (Txn.sender !== account) {
    txn Sender
    frame_dig -2
    !=
    bz addAddressToWhitelist_after_if_else@4
    // contracts/zk-whitelist.algo.ts:74
    // return "Sender address does not match authorized address";
    pushbytes "Sender address does not match authorized address"
    retsub

addAddressToWhitelist_after_if_else@4:
    // contracts/zk-whitelist.algo.ts:76
    // this.whiteList(account).value = true;
    frame_dig -2
    // contracts/zk-whitelist.algo.ts:28
    // whiteList = LocalState<boolean>();
    bytec_2 // "whiteList"
    // contracts/zk-whitelist.algo.ts:76
    // this.whiteList(account).value = true;
    intc_0 // 1
    app_local_put
    // contracts/zk-whitelist.algo.ts:77
    // return "";
    pushbytes ""
    retsub


// contracts/zk-whitelist.algo.ts::ZkWhitelistContract.isOnWhitelist(address: bytes) -> uint64:
isOnWhitelist:
    // contracts/zk-whitelist.algo.ts:80-81
    // @abimethod()
    // isOnWhitelist(address: arc4.Address): boolean {
    proto 1 1
    // contracts/zk-whitelist.algo.ts:84
    // const optedIn = op.appOptedIn(account, Global.currentApplicationId);
    frame_dig -1
    global CurrentApplicationID
    app_opted_in
    // contracts/zk-whitelist.algo.ts:85
    // if (!optedIn) {
    bnz isOnWhitelist_after_if_else@2
    // contracts/zk-whitelist.algo.ts:86
    // return false;
    intc_1 // 0
    retsub

isOnWhitelist_after_if_else@2:
    // contracts/zk-whitelist.algo.ts:88
    // return this.whiteList(account).value;
    frame_dig -1
    intc_1 // 0
    // contracts/zk-whitelist.algo.ts:28
    // whiteList = LocalState<boolean>();
    bytec_2 // "whiteList"
    // contracts/zk-whitelist.algo.ts:88
    // return this.whiteList(account).value;
    app_local_get_ex
    assert // check LocalState exists
    retsub


// contracts/zk-whitelist.algo.ts::ZkWhitelistContract.verifyProof(appId: uint64, proof: bytes, publicInputs: bytes) -> bytes:
verifyProof:
    // contracts/zk-whitelist.algo.ts:91-95
    // verifyProof(
    //   appId: uint64,
    //   proof: arc4.Address[],
    //   publicInputs: arc4.Address[],
    // ): arc4.Bool {
    proto 3 1
    // contracts/zk-whitelist.algo.ts:97-105
    // const verified = itxn
    //   .applicationCall({
    //     appId: appId,
    //     fee: 0,
    //     // Commented out until https://github.com/algorandfoundation/puya-ts/issues/116 is resolved
    //     // appArgs: [arc4.methodSelector('verify(byte[32][],byte[32][])bool'), proof, arc4.encodeArc4(publicInputs)],
    //     onCompletion: arc4.OnCompleteAction.NoOp,
    //   })
    //   .submit().lastLog;
    itxn_begin
    // contracts/zk-whitelist.algo.ts:103
    // onCompletion: arc4.OnCompleteAction.NoOp,
    intc_1 // 0
    itxn_field OnCompletion
    frame_dig -3
    itxn_field ApplicationID
    // contracts/zk-whitelist.algo.ts:97-104
    // const verified = itxn
    //   .applicationCall({
    //     appId: appId,
    //     fee: 0,
    //     // Commented out until https://github.com/algorandfoundation/puya-ts/issues/116 is resolved
    //     // appArgs: [arc4.methodSelector('verify(byte[32][],byte[32][])bool'), proof, arc4.encodeArc4(publicInputs)],
    //     onCompletion: arc4.OnCompleteAction.NoOp,
    //   })
    intc_2 // 6
    itxn_field TypeEnum
    // contracts/zk-whitelist.algo.ts:100
    // fee: 0,
    intc_1 // 0
    itxn_field Fee
    // contracts/zk-whitelist.algo.ts:97-105
    // const verified = itxn
    //   .applicationCall({
    //     appId: appId,
    //     fee: 0,
    //     // Commented out until https://github.com/algorandfoundation/puya-ts/issues/116 is resolved
    //     // appArgs: [arc4.methodSelector('verify(byte[32][],byte[32][])bool'), proof, arc4.encodeArc4(publicInputs)],
    //     onCompletion: arc4.OnCompleteAction.NoOp,
    //   })
    //   .submit().lastLog;
    itxn_submit
    // contracts/zk-whitelist.algo.ts:105
    // .submit().lastLog;
    itxn LastLog
    // contracts/zk-whitelist.algo.ts:106
    // return arc4.interpretAsArc4<arc4.Bool>(verified, "log");
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_0 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    retsub

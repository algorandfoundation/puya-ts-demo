#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 1 0 4 48 50500
    bytecblock "listings" base32(AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA) 0x151f7c75000000000000c544 0x0000000000000000
    // contracts/marketplace.algo.ts:30
    // export default class DigitalMarketplace extends arc4.Contract {
    txn NumAppArgs
    bz main_bare_routing@16
    pushbytess 0xbe4b31e3 0xa0cb3693 0xd98ef6a9 0x56efcfb5 0x12f08c98 0x9b4b8234 0x5a05bc57 0x1c80d714 0xcbc819e5 0xbc75ceb1 0xdd619204 // method "listingsBoxMbr()uint64", method "quantityPrice(uint64,uint64,uint64)uint64", method "getListingsMbr()uint64", method "allowAsset(pay,asset)void", method "firstDeposit(pay,axfer,uint64,uint64)void", method "deposit(axfer,uint64)void", method "setPrice(asset,uint64,uint64)void", method "buy(address,asset,uint64,pay,uint64)void", method "withdraw(asset,uint64)void", method "bid(address,asset,uint64,pay,uint64,uint64)void", method "acceptBid(asset,uint64)void"
    txna ApplicationArgs 0
    match main_listingsBoxMbr_route@3 main_quantityPrice_route@4 main_getListingsMbr_route@5 main_allowAsset_route@6 main_firstDeposit_route@7 main_deposit_route@8 main_setPrice_route@9 main_buy_route@10 main_withdraw_route@11 main_bid_route@12 main_acceptBid_route@13

main_after_if_else@20:
    // contracts/marketplace.algo.ts:30
    // export default class DigitalMarketplace extends arc4.Contract {
    intc_1 // 0
    return

main_acceptBid_route@13:
    // contracts/marketplace.algo.ts:308
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/marketplace.algo.ts:30
    // export default class DigitalMarketplace extends arc4.Contract {
    txna ApplicationArgs 1
    btoi
    txnas Assets
    txna ApplicationArgs 2
    // contracts/marketplace.algo.ts:308
    // @arc4.abimethod()
    callsub acceptBid
    intc_0 // 1
    return

main_bid_route@12:
    // contracts/marketplace.algo.ts:256
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/marketplace.algo.ts:30
    // export default class DigitalMarketplace extends arc4.Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    txnas Assets
    txna ApplicationArgs 3
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    // contracts/marketplace.algo.ts:256
    // @arc4.abimethod()
    callsub bid
    intc_0 // 1
    return

main_withdraw_route@11:
    // contracts/marketplace.algo.ts:221
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/marketplace.algo.ts:30
    // export default class DigitalMarketplace extends arc4.Contract {
    txna ApplicationArgs 1
    btoi
    txnas Assets
    txna ApplicationArgs 2
    // contracts/marketplace.algo.ts:221
    // @arc4.abimethod()
    callsub withdraw
    intc_0 // 1
    return

main_buy_route@10:
    // contracts/marketplace.algo.ts:175
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/marketplace.algo.ts:30
    // export default class DigitalMarketplace extends arc4.Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    txnas Assets
    txna ApplicationArgs 3
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 4
    btoi
    // contracts/marketplace.algo.ts:175
    // @arc4.abimethod()
    callsub buy
    intc_0 // 1
    return

main_setPrice_route@9:
    // contracts/marketplace.algo.ts:154
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/marketplace.algo.ts:30
    // export default class DigitalMarketplace extends arc4.Contract {
    txna ApplicationArgs 1
    btoi
    txnas Assets
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // contracts/marketplace.algo.ts:154
    // @arc4.abimethod()
    callsub setPrice
    intc_0 // 1
    return

main_deposit_route@8:
    // contracts/marketplace.algo.ts:127
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/marketplace.algo.ts:30
    // export default class DigitalMarketplace extends arc4.Contract {
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    // contracts/marketplace.algo.ts:127
    // @arc4.abimethod()
    callsub deposit
    intc_0 // 1
    return

main_firstDeposit_route@7:
    // contracts/marketplace.algo.ts:93
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/marketplace.algo.ts:30
    // export default class DigitalMarketplace extends arc4.Contract {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // contracts/marketplace.algo.ts:93
    // @arc4.abimethod()
    callsub firstDeposit
    intc_0 // 1
    return

main_allowAsset_route@6:
    // contracts/marketplace.algo.ts:77
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/marketplace.algo.ts:30
    // export default class DigitalMarketplace extends arc4.Contract {
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    btoi
    txnas Assets
    // contracts/marketplace.algo.ts:77
    // @arc4.abimethod()
    callsub allowAsset
    intc_0 // 1
    return

main_getListingsMbr_route@5:
    // contracts/marketplace.algo.ts:72
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec_2 // 0x151f7c75000000000000c544
    log
    intc_0 // 1
    return

main_quantityPrice_route@4:
    // contracts/marketplace.algo.ts:53-57
    // quantityPrice(
    //   quantity: uint64,
    //   price: uint64,
    //   assetDecimals: uint64,
    // ): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/marketplace.algo.ts:30
    // export default class DigitalMarketplace extends arc4.Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    // contracts/marketplace.algo.ts:53-57
    // quantityPrice(
    //   quantity: uint64,
    //   price: uint64,
    //   assetDecimals: uint64,
    // ): uint64 {
    callsub quantityPrice
    itob
    pushbytes 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_listingsBoxMbr_route@3:
    // contracts/marketplace.algo.ts:33
    // listingsBoxMbr(): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec_2 // 0x151f7c75000000000000c544
    log
    intc_0 // 1
    return

main_bare_routing@16:
    // contracts/marketplace.algo.ts:30
    // export default class DigitalMarketplace extends arc4.Contract {
    txn OnCompletion
    bnz main_after_if_else@20
    txn ApplicationID
    !
    assert // can only call when creating
    intc_0 // 1
    return


// contracts/marketplace.algo.ts::DigitalMarketplace.quantityPrice(quantity: uint64, price: uint64, assetDecimals: uint64) -> uint64:
quantityPrice:
    // contracts/marketplace.algo.ts:53-57
    // quantityPrice(
    //   quantity: uint64,
    //   price: uint64,
    //   assetDecimals: uint64,
    // ): uint64 {
    proto 3 1
    // contracts/marketplace.algo.ts:58
    // const [amountNotScaledHigh, amountNotScaledLow] = op.mulw(price, quantity);
    frame_dig -2
    frame_dig -3
    mulw
    // contracts/marketplace.algo.ts:59
    // const [scalingFactorHigh, scalingFactorLow] = op.expw(10, assetDecimals);
    pushint 10 // 10
    frame_dig -1
    expw
    // contracts/marketplace.algo.ts:61-66
    // op.divmodw(
    //   amountNotScaledHigh,
    //   amountNotScaledLow,
    //   scalingFactorHigh,
    //   scalingFactorLow,
    // );
    divmodw
    popn 2
    swap
    // contracts/marketplace.algo.ts:67
    // assert(_quotientHigh === 0);
    !
    assert
    // contracts/marketplace.algo.ts:69
    // return amountToBePaid;
    retsub


// contracts/marketplace.algo.ts::DigitalMarketplace.allowAsset(mbrPay: uint64, asset: uint64) -> void:
allowAsset:
    // contracts/marketplace.algo.ts:77-78
    // @arc4.abimethod()
    // allowAsset(mbrPay: gtxn.PaymentTxn, asset: Asset) {
    proto 2 0
    // contracts/marketplace.algo.ts:79
    // assert(!Global.currentApplicationAddress.isOptedIn(asset));
    global CurrentApplicationAddress
    frame_dig -1
    asset_holding_get AssetBalance
    bury 1
    !
    assert
    // contracts/marketplace.algo.ts:81
    // assert(mbrPay.receiver === Global.currentApplicationAddress);
    frame_dig -2
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert
    // contracts/marketplace.algo.ts:82
    // assert(mbrPay.amount === Global.assetOptInMinBalance);
    frame_dig -2
    gtxns Amount
    global AssetOptInMinBalance
    ==
    assert
    // contracts/marketplace.algo.ts:84-90
    // itxn
    //   .assetTransfer({
    //     xferAsset: asset,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //   })
    //   .submit();
    itxn_begin
    // contracts/marketplace.algo.ts:87
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // contracts/marketplace.algo.ts:88
    // assetAmount: 0,
    intc_1 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    frame_dig -1
    itxn_field XferAsset
    // contracts/marketplace.algo.ts:84-89
    // itxn
    //   .assetTransfer({
    //     xferAsset: asset,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    // contracts/marketplace.algo.ts:84-90
    // itxn
    //   .assetTransfer({
    //     xferAsset: asset,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    //   })
    //   .submit();
    itxn_submit
    retsub


// contracts/marketplace.algo.ts::DigitalMarketplace.firstDeposit(mbrPay: uint64, xfer: uint64, unitaryPrice: bytes, nonce: bytes) -> void:
firstDeposit:
    // contracts/marketplace.algo.ts:93-99
    // @arc4.abimethod()
    // firstDeposit(
    //   mbrPay: gtxn.PaymentTxn,
    //   xfer: gtxn.AssetTransferTxn,
    //   unitaryPrice: arc4.UintN64,
    //   nonce: arc4.UintN64,
    // ) {
    proto 4 0
    // contracts/marketplace.algo.ts:100
    // assert(mbrPay.sender === Txn.sender);
    frame_dig -4
    gtxns Sender
    txn Sender
    ==
    assert
    // contracts/marketplace.algo.ts:101
    // assert(mbrPay.receiver === Global.currentApplicationAddress);
    frame_dig -4
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert
    // contracts/marketplace.algo.ts:102
    // assert(mbrPay.amount === this.listingsBoxMbr());
    frame_dig -4
    gtxns Amount
    // contracts/marketplace.algo.ts:35-49
    // 2_500 +
    // // fmt: off
    // // Key length
    // (8 +
    //   32 +
    //   8 +
    //   8 +
    //   // Value length
    //   8 +
    //   8 +
    //   32 +
    //   8 +
    //   8) *
    //   // fmt: on
    //   400
    intc 4 // 50500
    // contracts/marketplace.algo.ts:102
    // assert(mbrPay.amount === this.listingsBoxMbr());
    ==
    assert
    // contracts/marketplace.algo.ts:105
    // owner: new arc4.Address(Txn.sender),
    txn Sender
    // contracts/marketplace.algo.ts:106
    // asset: new arc4.UintN64(xfer.xferAsset.id),
    frame_dig -3
    gtxns XferAsset
    itob
    // contracts/marketplace.algo.ts:104-108
    // const key = new ListingKey({
    //   owner: new arc4.Address(Txn.sender),
    //   asset: new arc4.UintN64(xfer.xferAsset.id),
    //   nonce: nonce,
    // });
    concat
    frame_dig -1
    concat
    // contracts/marketplace.algo.ts:31
    // listings = BoxMap<ListingKey, ListingValue>({ keyPrefix: "listings" });
    bytec_0 // "listings"
    // contracts/marketplace.algo.ts:109
    // assert(!this.listings.has(key));
    swap
    concat
    dup
    box_len
    bury 1
    !
    assert
    // contracts/marketplace.algo.ts:111
    // assert(xfer.sender === Txn.sender);
    frame_dig -3
    gtxns Sender
    txn Sender
    ==
    assert
    // contracts/marketplace.algo.ts:112
    // assert(xfer.assetReceiver === Global.currentApplicationAddress);
    frame_dig -3
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    assert
    // contracts/marketplace.algo.ts:113
    // assert(xfer.assetAmount > 0);
    frame_dig -3
    gtxns AssetAmount
    dup
    assert
    // contracts/marketplace.algo.ts:118
    // deposited: new arc4.UintN64(xfer.assetAmount),
    itob
    // contracts/marketplace.algo.ts:117-123
    // new ListingValue({
    //   deposited: new arc4.UintN64(xfer.assetAmount),
    //   unitaryPrice: unitaryPrice,
    //   bidder: new arc4.Address(),
    //   bid: new arc4.UintN64(),
    //   bidUnitaryPrice: new arc4.UintN64(),
    // }),
    frame_dig -2
    concat
    // contracts/marketplace.algo.ts:120
    // bidder: new arc4.Address(),
    bytec_1 // addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
    // contracts/marketplace.algo.ts:117-123
    // new ListingValue({
    //   deposited: new arc4.UintN64(xfer.assetAmount),
    //   unitaryPrice: unitaryPrice,
    //   bidder: new arc4.Address(),
    //   bid: new arc4.UintN64(),
    //   bidUnitaryPrice: new arc4.UintN64(),
    // }),
    concat
    // contracts/marketplace.algo.ts:121
    // bid: new arc4.UintN64(),
    bytec_3 // 0x0000000000000000
    // contracts/marketplace.algo.ts:117-123
    // new ListingValue({
    //   deposited: new arc4.UintN64(xfer.assetAmount),
    //   unitaryPrice: unitaryPrice,
    //   bidder: new arc4.Address(),
    //   bid: new arc4.UintN64(),
    //   bidUnitaryPrice: new arc4.UintN64(),
    // }),
    concat
    // contracts/marketplace.algo.ts:122
    // bidUnitaryPrice: new arc4.UintN64(),
    bytec_3 // 0x0000000000000000
    // contracts/marketplace.algo.ts:117-123
    // new ListingValue({
    //   deposited: new arc4.UintN64(xfer.assetAmount),
    //   unitaryPrice: unitaryPrice,
    //   bidder: new arc4.Address(),
    //   bid: new arc4.UintN64(),
    //   bidUnitaryPrice: new arc4.UintN64(),
    // }),
    concat
    // contracts/marketplace.algo.ts:115-124
    // this.listings.set(
    //   key,
    //   new ListingValue({
    //     deposited: new arc4.UintN64(xfer.assetAmount),
    //     unitaryPrice: unitaryPrice,
    //     bidder: new arc4.Address(),
    //     bid: new arc4.UintN64(),
    //     bidUnitaryPrice: new arc4.UintN64(),
    //   }),
    // );
    box_put
    retsub


// contracts/marketplace.algo.ts::DigitalMarketplace.deposit(xfer: uint64, nonce: bytes) -> void:
deposit:
    // contracts/marketplace.algo.ts:127-128
    // @arc4.abimethod()
    // deposit(xfer: gtxn.AssetTransferTxn, nonce: arc4.UintN64) {
    proto 2 0
    // contracts/marketplace.algo.ts:130
    // owner: new arc4.Address(Txn.sender),
    txn Sender
    // contracts/marketplace.algo.ts:131
    // asset: new arc4.UintN64(xfer.xferAsset.id),
    frame_dig -2
    gtxns XferAsset
    itob
    // contracts/marketplace.algo.ts:129-133
    // const key = new ListingKey({
    //   owner: new arc4.Address(Txn.sender),
    //   asset: new arc4.UintN64(xfer.xferAsset.id),
    //   nonce: nonce,
    // });
    concat
    frame_dig -1
    concat
    // contracts/marketplace.algo.ts:135
    // assert(xfer.sender === Txn.sender);
    frame_dig -2
    gtxns Sender
    txn Sender
    ==
    assert
    // contracts/marketplace.algo.ts:136
    // assert(xfer.assetReceiver === Global.currentApplicationAddress);
    frame_dig -2
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    assert
    // contracts/marketplace.algo.ts:137
    // assert(xfer.assetAmount > 0);
    frame_dig -2
    gtxns AssetAmount
    dup
    assert
    // contracts/marketplace.algo.ts:31
    // listings = BoxMap<ListingKey, ListingValue>({ keyPrefix: "listings" });
    bytec_0 // "listings"
    // contracts/marketplace.algo.ts:139
    // const existing = this.listings.get(key);
    uncover 2
    concat
    dup
    box_get
    assert // Box must have value
    // contracts/marketplace.algo.ts:148
    // existing.deposited.native + xfer.assetAmount,
    dup
    intc_1 // 0
    extract_uint64
    uncover 3
    +
    // contracts/marketplace.algo.ts:147-149
    // deposited: new arc4.UintN64(
    //   existing.deposited.native + xfer.assetAmount,
    // ),
    itob
    // contracts/marketplace.algo.ts:146
    // unitaryPrice: existing.unitaryPrice,
    dig 1
    extract 8 8 // on error: Index access is out of bounds
    // contracts/marketplace.algo.ts:145
    // bidder: existing.bidder,
    dig 2
    extract 16 32 // on error: Index access is out of bounds
    // contracts/marketplace.algo.ts:143
    // bid: existing.bid,
    dig 3
    extract 48 8 // on error: Index access is out of bounds
    // contracts/marketplace.algo.ts:144
    // bidUnitaryPrice: existing.bidUnitaryPrice,
    uncover 4
    extract 56 8 // on error: Index access is out of bounds
    // contracts/marketplace.algo.ts:142-150
    // new ListingValue({
    //   bid: existing.bid,
    //   bidUnitaryPrice: existing.bidUnitaryPrice,
    //   bidder: existing.bidder,
    //   unitaryPrice: existing.unitaryPrice,
    //   deposited: new arc4.UintN64(
    //     existing.deposited.native + xfer.assetAmount,
    //   ),
    // }),
    uncover 4
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // contracts/marketplace.algo.ts:140-151
    // this.listings.set(
    //   key,
    //   new ListingValue({
    //     bid: existing.bid,
    //     bidUnitaryPrice: existing.bidUnitaryPrice,
    //     bidder: existing.bidder,
    //     unitaryPrice: existing.unitaryPrice,
    //     deposited: new arc4.UintN64(
    //       existing.deposited.native + xfer.assetAmount,
    //     ),
    //   }),
    // );
    box_put
    retsub


// contracts/marketplace.algo.ts::DigitalMarketplace.setPrice(asset: uint64, nonce: bytes, unitaryPrice: bytes) -> void:
setPrice:
    // contracts/marketplace.algo.ts:154-155
    // @arc4.abimethod()
    // setPrice(asset: Asset, nonce: arc4.UintN64, unitaryPrice: arc4.UintN64) {
    proto 3 0
    // contracts/marketplace.algo.ts:157
    // owner: new arc4.Address(Txn.sender),
    txn Sender
    // contracts/marketplace.algo.ts:158
    // asset: new arc4.UintN64(asset.id),
    frame_dig -3
    itob
    // contracts/marketplace.algo.ts:156-160
    // const key = new ListingKey({
    //   owner: new arc4.Address(Txn.sender),
    //   asset: new arc4.UintN64(asset.id),
    //   nonce: nonce,
    // });
    concat
    frame_dig -2
    concat
    // contracts/marketplace.algo.ts:31
    // listings = BoxMap<ListingKey, ListingValue>({ keyPrefix: "listings" });
    bytec_0 // "listings"
    // contracts/marketplace.algo.ts:162
    // const existing = this.listings.get(key);
    swap
    concat
    dup
    box_get
    assert // Box must have value
    // contracts/marketplace.algo.ts:169
    // deposited: existing.deposited,
    dup
    extract 0 8 // on error: Index access is out of bounds
    // contracts/marketplace.algo.ts:168
    // bidder: existing.bidder,
    dig 1
    extract 16 32 // on error: Index access is out of bounds
    // contracts/marketplace.algo.ts:166
    // bid: existing.bid,
    dig 2
    extract 48 8 // on error: Index access is out of bounds
    // contracts/marketplace.algo.ts:167
    // bidUnitaryPrice: existing.bidUnitaryPrice,
    uncover 3
    extract 56 8 // on error: Index access is out of bounds
    // contracts/marketplace.algo.ts:165-171
    // new ListingValue({
    //   bid: existing.bid,
    //   bidUnitaryPrice: existing.bidUnitaryPrice,
    //   bidder: existing.bidder,
    //   deposited: existing.deposited,
    //   unitaryPrice: unitaryPrice,
    // }),
    uncover 3
    frame_dig -1
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // contracts/marketplace.algo.ts:163-172
    // this.listings.set(
    //   key,
    //   new ListingValue({
    //     bid: existing.bid,
    //     bidUnitaryPrice: existing.bidUnitaryPrice,
    //     bidder: existing.bidder,
    //     deposited: existing.deposited,
    //     unitaryPrice: unitaryPrice,
    //   }),
    // );
    box_put
    retsub


// contracts/marketplace.algo.ts::DigitalMarketplace.buy(owner: bytes, asset: uint64, nonce: bytes, buyPay: uint64, quantity: uint64) -> void:
buy:
    // contracts/marketplace.algo.ts:175-182
    // @arc4.abimethod()
    // buy(
    //   owner: arc4.Address,
    //   asset: Asset,
    //   nonce: arc4.UintN64,
    //   buyPay: gtxn.PaymentTxn,
    //   quantity: uint64,
    // ) {
    proto 5 0
    // contracts/marketplace.algo.ts:185
    // asset: new arc4.UintN64(asset.id),
    frame_dig -4
    itob
    // contracts/marketplace.algo.ts:183-187
    // const key = new ListingKey({
    //   owner: owner,
    //   asset: new arc4.UintN64(asset.id),
    //   nonce: nonce,
    // });
    frame_dig -5
    swap
    concat
    frame_dig -3
    concat
    // contracts/marketplace.algo.ts:31
    // listings = BoxMap<ListingKey, ListingValue>({ keyPrefix: "listings" });
    bytec_0 // "listings"
    // contracts/marketplace.algo.ts:189
    // const listing = this.listings.get(key);
    swap
    concat
    dup
    box_get
    assert // Box must have value
    // contracts/marketplace.algo.ts:193
    // listing.unitaryPrice.native,
    dup
    extract 8 8 // on error: Index access is out of bounds
    dig 1
    pushint 8 // 8
    extract_uint64
    // contracts/marketplace.algo.ts:194
    // asset.decimals,
    frame_dig -4
    asset_params_get AssetDecimals
    assert // asset exists
    // contracts/marketplace.algo.ts:191-195
    // const amountToBePaid = this.quantityPrice(
    //   quantity,
    //   listing.unitaryPrice.native,
    //   asset.decimals,
    // );
    frame_dig -1
    cover 2
    callsub quantityPrice
    // contracts/marketplace.algo.ts:197
    // assert(buyPay.sender === Txn.sender);
    frame_dig -2
    gtxns Sender
    txn Sender
    ==
    assert
    // contracts/marketplace.algo.ts:198
    // assert(buyPay.receiver.bytes === owner.bytes);
    frame_dig -2
    gtxns Receiver
    frame_dig -5
    ==
    assert
    // contracts/marketplace.algo.ts:199
    // assert(buyPay.amount === amountToBePaid);
    frame_dig -2
    gtxns Amount
    ==
    assert
    // contracts/marketplace.algo.ts:208
    // deposited: new arc4.UintN64(listing.deposited.native - quantity),
    dig 1
    intc_1 // 0
    extract_uint64
    frame_dig -1
    -
    itob
    // contracts/marketplace.algo.ts:206
    // bidder: listing.bidder,
    dig 2
    extract 16 32 // on error: Index access is out of bounds
    // contracts/marketplace.algo.ts:204
    // bid: listing.bid,
    dig 3
    extract 48 8 // on error: Index access is out of bounds
    // contracts/marketplace.algo.ts:205
    // bidUnitaryPrice: listing.bidUnitaryPrice,
    uncover 4
    extract 56 8 // on error: Index access is out of bounds
    // contracts/marketplace.algo.ts:203-209
    // new ListingValue({
    //   bid: listing.bid,
    //   bidUnitaryPrice: listing.bidUnitaryPrice,
    //   bidder: listing.bidder,
    //   unitaryPrice: listing.unitaryPrice,
    //   deposited: new arc4.UintN64(listing.deposited.native - quantity),
    // }),
    uncover 3
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // contracts/marketplace.algo.ts:201-210
    // this.listings.set(
    //   key,
    //   new ListingValue({
    //     bid: listing.bid,
    //     bidUnitaryPrice: listing.bidUnitaryPrice,
    //     bidder: listing.bidder,
    //     unitaryPrice: listing.unitaryPrice,
    //     deposited: new arc4.UintN64(listing.deposited.native - quantity),
    //   }),
    // );
    box_put
    // contracts/marketplace.algo.ts:212-218
    // itxn
    //   .assetTransfer({
    //     xferAsset: asset,
    //     assetReceiver: Txn.sender,
    //     assetAmount: quantity,
    //   })
    //   .submit();
    itxn_begin
    // contracts/marketplace.algo.ts:215
    // assetReceiver: Txn.sender,
    txn Sender
    frame_dig -1
    itxn_field AssetAmount
    itxn_field AssetReceiver
    frame_dig -4
    itxn_field XferAsset
    // contracts/marketplace.algo.ts:212-217
    // itxn
    //   .assetTransfer({
    //     xferAsset: asset,
    //     assetReceiver: Txn.sender,
    //     assetAmount: quantity,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    // contracts/marketplace.algo.ts:212-218
    // itxn
    //   .assetTransfer({
    //     xferAsset: asset,
    //     assetReceiver: Txn.sender,
    //     assetAmount: quantity,
    //   })
    //   .submit();
    itxn_submit
    retsub


// contracts/marketplace.algo.ts::DigitalMarketplace.withdraw(asset: uint64, nonce: bytes) -> void:
withdraw:
    // contracts/marketplace.algo.ts:221-222
    // @arc4.abimethod()
    // withdraw(asset: Asset, nonce: arc4.UintN64) {
    proto 2 0
    // contracts/marketplace.algo.ts:224
    // owner: new arc4.Address(Txn.sender),
    txn Sender
    // contracts/marketplace.algo.ts:225
    // asset: new arc4.UintN64(asset.id),
    frame_dig -2
    itob
    // contracts/marketplace.algo.ts:223-227
    // const key = new ListingKey({
    //   owner: new arc4.Address(Txn.sender),
    //   asset: new arc4.UintN64(asset.id),
    //   nonce: nonce,
    // });
    concat
    frame_dig -1
    concat
    // contracts/marketplace.algo.ts:31
    // listings = BoxMap<ListingKey, ListingValue>({ keyPrefix: "listings" });
    bytec_0 // "listings"
    // contracts/marketplace.algo.ts:229
    // const listing = this.listings.get(key);
    swap
    concat
    dup
    box_get
    swap
    dup
    uncover 2
    assert // Box must have value
    // contracts/marketplace.algo.ts:230
    // if (listing.bidder !== new arc4.Address()) {
    extract 16 32 // on error: Index access is out of bounds
    dup
    bytec_1 // addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
    !=
    bz withdraw_after_if_else@3
    // contracts/marketplace.algo.ts:232
    // listing.bid.native,
    frame_dig 1
    dup
    intc_3 // 48
    extract_uint64
    // contracts/marketplace.algo.ts:233
    // listing.bidUnitaryPrice.native,
    swap
    pushint 56 // 56
    extract_uint64
    // contracts/marketplace.algo.ts:234
    // asset.decimals,
    frame_dig -2
    asset_params_get AssetDecimals
    assert // asset exists
    // contracts/marketplace.algo.ts:231-235
    // const currentBidDeposit = this.quantityPrice(
    //   listing.bid.native,
    //   listing.bidUnitaryPrice.native,
    //   asset.decimals,
    // );
    callsub quantityPrice
    // contracts/marketplace.algo.ts:236-238
    // itxn
    //   .payment({ receiver: listing.bidder.native, amount: currentBidDeposit })
    //   .submit();
    itxn_begin
    itxn_field Amount
    frame_dig 2
    itxn_field Receiver
    // contracts/marketplace.algo.ts:236-237
    // itxn
    //   .payment({ receiver: listing.bidder.native, amount: currentBidDeposit })
    intc_0 // 1
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    // contracts/marketplace.algo.ts:236-238
    // itxn
    //   .payment({ receiver: listing.bidder.native, amount: currentBidDeposit })
    //   .submit();
    itxn_submit

withdraw_after_if_else@3:
    // contracts/marketplace.algo.ts:241
    // this.listings.delete(key);
    frame_dig 0
    box_del
    pop
    // contracts/marketplace.algo.ts:243-245
    // itxn
    //   .payment({ receiver: Txn.sender, amount: this.listingsBoxMbr() })
    //   .submit();
    itxn_begin
    // contracts/marketplace.algo.ts:244
    // .payment({ receiver: Txn.sender, amount: this.listingsBoxMbr() })
    txn Sender
    // contracts/marketplace.algo.ts:35-49
    // 2_500 +
    // // fmt: off
    // // Key length
    // (8 +
    //   32 +
    //   8 +
    //   8 +
    //   // Value length
    //   8 +
    //   8 +
    //   32 +
    //   8 +
    //   8) *
    //   // fmt: on
    //   400
    intc 4 // 50500
    itxn_field Amount
    itxn_field Receiver
    // contracts/marketplace.algo.ts:243-244
    // itxn
    //   .payment({ receiver: Txn.sender, amount: this.listingsBoxMbr() })
    intc_0 // 1
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    // contracts/marketplace.algo.ts:243-245
    // itxn
    //   .payment({ receiver: Txn.sender, amount: this.listingsBoxMbr() })
    //   .submit();
    itxn_submit
    // contracts/marketplace.algo.ts:247-253
    // itxn
    //   .assetTransfer({
    //     xferAsset: asset,
    //     assetReceiver: Txn.sender,
    //     assetAmount: listing.deposited.native,
    //   })
    //   .submit();
    itxn_begin
    // contracts/marketplace.algo.ts:250
    // assetReceiver: Txn.sender,
    txn Sender
    // contracts/marketplace.algo.ts:251
    // assetAmount: listing.deposited.native,
    frame_dig 1
    intc_1 // 0
    extract_uint64
    itxn_field AssetAmount
    itxn_field AssetReceiver
    frame_dig -2
    itxn_field XferAsset
    // contracts/marketplace.algo.ts:247-252
    // itxn
    //   .assetTransfer({
    //     xferAsset: asset,
    //     assetReceiver: Txn.sender,
    //     assetAmount: listing.deposited.native,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    // contracts/marketplace.algo.ts:247-253
    // itxn
    //   .assetTransfer({
    //     xferAsset: asset,
    //     assetReceiver: Txn.sender,
    //     assetAmount: listing.deposited.native,
    //   })
    //   .submit();
    itxn_submit
    retsub


// contracts/marketplace.algo.ts::DigitalMarketplace.bid(owner: bytes, asset: uint64, nonce: bytes, bidPay: uint64, quantity: bytes, unitaryPrice: bytes) -> void:
bid:
    // contracts/marketplace.algo.ts:256-264
    // @arc4.abimethod()
    // bid(
    //   owner: arc4.Address,
    //   asset: Asset,
    //   nonce: arc4.UintN64,
    //   bidPay: gtxn.PaymentTxn,
    //   quantity: arc4.UintN64,
    //   unitaryPrice: arc4.UintN64,
    // ) {
    proto 6 0
    // contracts/marketplace.algo.ts:267
    // asset: new arc4.UintN64(asset.id),
    frame_dig -5
    itob
    // contracts/marketplace.algo.ts:265-269
    // const key = new ListingKey({
    //   owner,
    //   asset: new arc4.UintN64(asset.id),
    //   nonce,
    // });
    frame_dig -6
    swap
    concat
    frame_dig -4
    concat
    // contracts/marketplace.algo.ts:31
    // listings = BoxMap<ListingKey, ListingValue>({ keyPrefix: "listings" });
    bytec_0 // "listings"
    // contracts/marketplace.algo.ts:271
    // const listing = this.listings.get(key);
    swap
    concat
    dup
    box_get
    swap
    dup
    uncover 2
    assert // Box must have value
    // contracts/marketplace.algo.ts:272
    // if (listing.bidder !== new arc4.Address()) {
    extract 16 32 // on error: Index access is out of bounds
    dup
    bytec_1 // addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
    !=
    bz bid_after_if_else@3
    // contracts/marketplace.algo.ts:273
    // assert(unitaryPrice.native > listing.bidUnitaryPrice.native);
    frame_dig -1
    btoi
    frame_dig 1
    dup
    cover 2
    pushint 56 // 56
    extract_uint64
    swap
    dig 1
    >
    assert
    // contracts/marketplace.algo.ts:276
    // listing.bid.native,
    swap
    intc_3 // 48
    extract_uint64
    // contracts/marketplace.algo.ts:278
    // asset.decimals,
    frame_dig -5
    asset_params_get AssetDecimals
    assert // asset exists
    // contracts/marketplace.algo.ts:275-279
    // const currentBidAmount = this.quantityPrice(
    //   listing.bid.native,
    //   listing.bidUnitaryPrice.native,
    //   asset.decimals,
    // );
    swap
    cover 2
    callsub quantityPrice
    // contracts/marketplace.algo.ts:281-283
    // itxn
    //   .payment({ receiver: listing.bidder.native, amount: currentBidAmount })
    //   .submit();
    itxn_begin
    itxn_field Amount
    frame_dig 2
    itxn_field Receiver
    // contracts/marketplace.algo.ts:281-282
    // itxn
    //   .payment({ receiver: listing.bidder.native, amount: currentBidAmount })
    intc_0 // 1
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    // contracts/marketplace.algo.ts:281-283
    // itxn
    //   .payment({ receiver: listing.bidder.native, amount: currentBidAmount })
    //   .submit();
    itxn_submit

bid_after_if_else@3:
    // contracts/marketplace.algo.ts:287
    // quantity.native,
    frame_dig -2
    btoi
    // contracts/marketplace.algo.ts:288
    // unitaryPrice.native,
    frame_dig -1
    btoi
    // contracts/marketplace.algo.ts:289
    // asset.decimals,
    frame_dig -5
    asset_params_get AssetDecimals
    assert // asset exists
    // contracts/marketplace.algo.ts:286-290
    // const amountToBeBid = this.quantityPrice(
    //   quantity.native,
    //   unitaryPrice.native,
    //   asset.decimals,
    // );
    callsub quantityPrice
    // contracts/marketplace.algo.ts:292
    // assert(bidPay.sender === Txn.sender);
    frame_dig -3
    gtxns Sender
    txn Sender
    ==
    assert
    // contracts/marketplace.algo.ts:293
    // assert(bidPay.receiver === Global.currentApplicationAddress);
    frame_dig -3
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert
    // contracts/marketplace.algo.ts:294
    // assert(bidPay.amount === amountToBeBid);
    frame_dig -3
    gtxns Amount
    ==
    assert
    // contracts/marketplace.algo.ts:299
    // deposited: listing.deposited,
    frame_dig 1
    dup
    extract 0 8 // on error: Index access is out of bounds
    // contracts/marketplace.algo.ts:300
    // unitaryPrice: listing.unitaryPrice,
    swap
    extract 8 8 // on error: Index access is out of bounds
    // contracts/marketplace.algo.ts:301
    // bidder: new arc4.Address(Txn.sender),
    txn Sender
    // contracts/marketplace.algo.ts:298-304
    // new ListingValue({
    //   deposited: listing.deposited,
    //   unitaryPrice: listing.unitaryPrice,
    //   bidder: new arc4.Address(Txn.sender),
    //   bid: quantity,
    //   bidUnitaryPrice: unitaryPrice,
    // }),
    cover 2
    concat
    swap
    concat
    frame_dig -2
    concat
    frame_dig -1
    concat
    // contracts/marketplace.algo.ts:296-305
    // this.listings.set(
    //   key,
    //   new ListingValue({
    //     deposited: listing.deposited,
    //     unitaryPrice: listing.unitaryPrice,
    //     bidder: new arc4.Address(Txn.sender),
    //     bid: quantity,
    //     bidUnitaryPrice: unitaryPrice,
    //   }),
    // );
    frame_dig 0
    swap
    box_put
    retsub


// contracts/marketplace.algo.ts::DigitalMarketplace.acceptBid(asset: uint64, nonce: bytes) -> void:
acceptBid:
    // contracts/marketplace.algo.ts:308-309
    // @arc4.abimethod()
    // acceptBid(asset: Asset, nonce: arc4.UintN64) {
    proto 2 0
    // contracts/marketplace.algo.ts:311
    // owner: new arc4.Address(Txn.sender),
    txn Sender
    // contracts/marketplace.algo.ts:312
    // asset: new arc4.UintN64(asset.id),
    frame_dig -2
    itob
    // contracts/marketplace.algo.ts:310-314
    // const key = new ListingKey({
    //   owner: new arc4.Address(Txn.sender),
    //   asset: new arc4.UintN64(asset.id),
    //   nonce,
    // });
    concat
    frame_dig -1
    concat
    // contracts/marketplace.algo.ts:31
    // listings = BoxMap<ListingKey, ListingValue>({ keyPrefix: "listings" });
    bytec_0 // "listings"
    // contracts/marketplace.algo.ts:316
    // const listing = this.listings.get(key);
    swap
    concat
    dup
    box_get
    swap
    dup
    uncover 2
    assert // Box must have value
    // contracts/marketplace.algo.ts:317
    // assert(listing.bidder !== new arc4.Address());
    dup
    extract 16 32 // on error: Index access is out of bounds
    dup
    cover 2
    bytec_1 // addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
    !=
    assert
    // contracts/marketplace.algo.ts:320
    // listing.deposited.native < listing.bid.native
    dup
    intc_1 // 0
    extract_uint64
    dup
    uncover 2
    intc_3 // 48
    extract_uint64
    dup
    cover 2
    <
    // contracts/marketplace.algo.ts:320-322
    // listing.deposited.native < listing.bid.native
    //   ? listing.deposited.native
    //   : listing.bid.native;
    bz acceptBid_ternary_false@2
    frame_dig 3

acceptBid_ternary_merge@3:
    // contracts/marketplace.algo.ts:326
    // listing.bidUnitaryPrice.native,
    frame_dig 1
    dup
    extract 56 8 // on error: Index access is out of bounds
    dig 1
    pushint 56 // 56
    extract_uint64
    // contracts/marketplace.algo.ts:327
    // asset.decimals,
    frame_dig -2
    asset_params_get AssetDecimals
    assert // asset exists
    // contracts/marketplace.algo.ts:324-328
    // const bestBidAmount = this.quantityPrice(
    //   minQuantity,
    //   listing.bidUnitaryPrice.native,
    //   asset.decimals,
    // );
    uncover 4
    dup
    cover 3
    cover 2
    callsub quantityPrice
    // contracts/marketplace.algo.ts:330
    // itxn.payment({ receiver: Txn.sender, amount: bestBidAmount }).submit();
    itxn_begin
    txn Sender
    itxn_field Receiver
    itxn_field Amount
    intc_0 // 1
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    itxn_submit
    // contracts/marketplace.algo.ts:332-338
    // itxn
    //   .assetTransfer({
    //     xferAsset: asset,
    //     assetReceiver: listing.bidder.native,
    //     assetAmount: minQuantity,
    //   })
    //   .submit();
    itxn_begin
    dup
    itxn_field AssetAmount
    frame_dig 2
    dup
    cover 2
    itxn_field AssetReceiver
    frame_dig -2
    itxn_field XferAsset
    // contracts/marketplace.algo.ts:332-337
    // itxn
    //   .assetTransfer({
    //     xferAsset: asset,
    //     assetReceiver: listing.bidder.native,
    //     assetAmount: minQuantity,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    // contracts/marketplace.algo.ts:332-338
    // itxn
    //   .assetTransfer({
    //     xferAsset: asset,
    //     assetReceiver: listing.bidder.native,
    //     assetAmount: minQuantity,
    //   })
    //   .submit();
    itxn_submit
    // contracts/marketplace.algo.ts:346
    // deposited: new arc4.UintN64(listing.deposited.native - minQuantity),
    frame_dig 3
    dig 1
    -
    itob
    // contracts/marketplace.algo.ts:347
    // bid: new arc4.UintN64(listing.bid.native - minQuantity),
    frame_dig 4
    uncover 2
    -
    // contracts/marketplace.algo.ts:345
    // unitaryPrice: listing.unitaryPrice,
    uncover 4
    extract 8 8 // on error: Index access is out of bounds
    // contracts/marketplace.algo.ts:347
    // bid: new arc4.UintN64(listing.bid.native - minQuantity),
    swap
    itob
    // contracts/marketplace.algo.ts:342-348
    // new ListingValue({
    //   bidder: listing.bidder,
    //   bidUnitaryPrice: listing.bidUnitaryPrice,
    //   unitaryPrice: listing.unitaryPrice,
    //   deposited: new arc4.UintN64(listing.deposited.native - minQuantity),
    //   bid: new arc4.UintN64(listing.bid.native - minQuantity),
    // }),
    cover 2
    concat
    uncover 2
    concat
    swap
    concat
    swap
    concat
    // contracts/marketplace.algo.ts:340-349
    // this.listings.set(
    //   key,
    //   new ListingValue({
    //     bidder: listing.bidder,
    //     bidUnitaryPrice: listing.bidUnitaryPrice,
    //     unitaryPrice: listing.unitaryPrice,
    //     deposited: new arc4.UintN64(listing.deposited.native - minQuantity),
    //     bid: new arc4.UintN64(listing.bid.native - minQuantity),
    //   }),
    // );
    frame_dig 0
    swap
    box_put
    retsub

acceptBid_ternary_false@2:
    frame_dig 4
    b acceptBid_ternary_merge@3

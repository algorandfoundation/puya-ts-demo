#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 4
    bytecblock "totalAttendees" "maxAttendees" 0x151f7c75 "boxMap" "assetUrl" 0x068101
    txn ApplicationID
    bnz main_after_if_else@2
    // contracts/proof-of-attendance.algo.ts:26
    // maxAttendees = GlobalState({ initialValue: Uint64(30) });
    bytec_1 // "maxAttendees"
    pushint 30 // 30
    app_global_put
    // contracts/proof-of-attendance.algo.ts:27
    // assetUrl = GlobalState({
    bytec 4 // "assetUrl"
    // contracts/proof-of-attendance.algo.ts:28
    // initialValue: "ipfs://QmW5vERkgeJJtSY1YQdcWU6gsHCZCyLFtM1oT9uyy2WGm8",
    pushbytes "ipfs://QmW5vERkgeJJtSY1YQdcWU6gsHCZCyLFtM1oT9uyy2WGm8"
    // contracts/proof-of-attendance.algo.ts:27-29
    // assetUrl = GlobalState({
    //   initialValue: "ipfs://QmW5vERkgeJJtSY1YQdcWU6gsHCZCyLFtM1oT9uyy2WGm8",
    // });
    app_global_put
    // contracts/proof-of-attendance.algo.ts:30
    // totalAttendees = GlobalState({ initialValue: Uint64(0) });
    bytec_0 // "totalAttendees"
    intc_0 // 0
    app_global_put

main_after_if_else@2:
    // contracts/proof-of-attendance.algo.ts:25
    // export default class ProofOfAttendance extends arc4.Contract {
    txn NumAppArgs
    bz main_after_if_else@21
    pushbytess 0x1bcde52d 0x09527352 0x34ef747b 0x7732a900 0x8485a195 0x7f8cf0ab 0xdd617d7d 0x9b487a80 0xba796fea 0x7de97566 0x83dd375f 0x765a33da 0x2c7a818c // method "init(uint64)void", method "confirmAttendance()void", method "confirmAttendanceWithBox()void", method "confirmAttendanceWithBoxRef()void", method "confirmAttendanceWithBoxMap()void", method "getPoaId()uint64", method "getPoaIdWithBox()uint64", method "getPoaIdWithBoxRef()uint64", method "getPoaIdWithBoxMap()uint64", method "claimPoa(axfer)void", method "claimPoaWithBox(axfer)void", method "claimPoaWithBoxRef(axfer)void", method "claimPoaWithBoxMap(axfer)void"
    txna ApplicationArgs 0
    match main_init_route@5 main_confirmAttendance_route@6 main_confirmAttendanceWithBox_route@7 main_confirmAttendanceWithBoxRef_route@8 main_confirmAttendanceWithBoxMap_route@9 main_getPoaId_route@10 main_getPoaIdWithBox_route@11 main_getPoaIdWithBoxRef_route@12 main_getPoaIdWithBoxMap_route@13 main_claimPoa_route@14 main_claimPoaWithBox_route@15 main_claimPoaWithBoxRef_route@16 main_claimPoaWithBoxMap_route@17

main_after_if_else@21:
    // contracts/proof-of-attendance.algo.ts:25
    // export default class ProofOfAttendance extends arc4.Contract {
    intc_0 // 0
    return

main_claimPoaWithBoxMap_route@17:
    // contracts/proof-of-attendance.algo.ts:199
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/proof-of-attendance.algo.ts:25
    // export default class ProofOfAttendance extends arc4.Contract {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    // contracts/proof-of-attendance.algo.ts:199
    // @arc4.abimethod()
    callsub claimPoaWithBoxMap
    intc_1 // 1
    return

main_claimPoaWithBoxRef_route@16:
    // contracts/proof-of-attendance.algo.ts:177
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/proof-of-attendance.algo.ts:25
    // export default class ProofOfAttendance extends arc4.Contract {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    // contracts/proof-of-attendance.algo.ts:177
    // @arc4.abimethod()
    callsub claimPoaWithBoxRef
    intc_1 // 1
    return

main_claimPoaWithBox_route@15:
    // contracts/proof-of-attendance.algo.ts:155
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/proof-of-attendance.algo.ts:25
    // export default class ProofOfAttendance extends arc4.Contract {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    // contracts/proof-of-attendance.algo.ts:155
    // @arc4.abimethod()
    callsub claimPoaWithBox
    intc_1 // 1
    return

main_claimPoa_route@14:
    // contracts/proof-of-attendance.algo.ts:134
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/proof-of-attendance.algo.ts:25
    // export default class ProofOfAttendance extends arc4.Contract {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    // contracts/proof-of-attendance.algo.ts:134
    // @arc4.abimethod()
    callsub claimPoa
    intc_1 // 1
    return

main_getPoaIdWithBoxMap_route@13:
    // contracts/proof-of-attendance.algo.ts:127
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getPoaIdWithBoxMap
    itob
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getPoaIdWithBoxRef_route@12:
    // contracts/proof-of-attendance.algo.ts:119
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getPoaIdWithBoxRef
    itob
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getPoaIdWithBox_route@11:
    // contracts/proof-of-attendance.algo.ts:111
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getPoaIdWithBox
    itob
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getPoaId_route@10:
    // contracts/proof-of-attendance.algo.ts:104
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getPoaId
    itob
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_confirmAttendanceWithBoxMap_route@9:
    // contracts/proof-of-attendance.algo.ts:89
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub confirmAttendanceWithBoxMap
    intc_1 // 1
    return

main_confirmAttendanceWithBoxRef_route@8:
    // contracts/proof-of-attendance.algo.ts:72
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub confirmAttendanceWithBoxRef
    intc_1 // 1
    return

main_confirmAttendanceWithBox_route@7:
    // contracts/proof-of-attendance.algo.ts:55
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub confirmAttendanceWithBox
    intc_1 // 1
    return

main_confirmAttendance_route@6:
    // contracts/proof-of-attendance.algo.ts:39
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub confirmAttendance
    intc_1 // 1
    return

main_init_route@5:
    // contracts/proof-of-attendance.algo.ts:33
    // @arc4.abimethod({ onCreate: "require" })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // contracts/proof-of-attendance.algo.ts:25
    // export default class ProofOfAttendance extends arc4.Contract {
    txna ApplicationArgs 1
    btoi
    // contracts/proof-of-attendance.algo.ts:33
    // @arc4.abimethod({ onCreate: "require" })
    callsub init
    intc_1 // 1
    return


// contracts/proof-of-attendance.algo.ts::ProofOfAttendance.init(maxAttendees: uint64) -> void:
init:
    // contracts/proof-of-attendance.algo.ts:33-34
    // @arc4.abimethod({ onCreate: "require" })
    // init(maxAttendees: uint64) {
    proto 1 0
    // contracts/proof-of-attendance.algo.ts:35
    // assert(Txn.sender === Global.creatorAddress, "Only creator can initialize");
    txn Sender
    global CreatorAddress
    ==
    assert // Only creator can initialize
    // contracts/proof-of-attendance.algo.ts:26
    // maxAttendees = GlobalState({ initialValue: Uint64(30) });
    bytec_1 // "maxAttendees"
    // contracts/proof-of-attendance.algo.ts:36
    // this.maxAttendees.value = maxAttendees;
    frame_dig -1
    app_global_put
    retsub


// contracts/proof-of-attendance.algo.ts::ProofOfAttendance.confirmAttendance() -> void:
confirmAttendance:
    // contracts/proof-of-attendance.algo.ts:30
    // totalAttendees = GlobalState({ initialValue: Uint64(0) });
    intc_0 // 0
    bytec_0 // "totalAttendees"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/proof-of-attendance.algo.ts:26
    // maxAttendees = GlobalState({ initialValue: Uint64(30) });
    intc_0 // 0
    bytec_1 // "maxAttendees"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/proof-of-attendance.algo.ts:42
    // this.totalAttendees.value < this.maxAttendees.value,
    <
    // contracts/proof-of-attendance.algo.ts:41-44
    // assert(
    //   this.totalAttendees.value < this.maxAttendees.value,
    //   "Max attendees reached",
    // );
    assert // Max attendees reached
    // contracts/proof-of-attendance.algo.ts:46
    // const mintedAsset = this.mintPoa(Txn.sender);
    txn Sender
    callsub mintPoa
    // contracts/proof-of-attendance.algo.ts:30
    // totalAttendees = GlobalState({ initialValue: Uint64(0) });
    intc_0 // 0
    bytec_0 // "totalAttendees"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/proof-of-attendance.algo.ts:47
    // this.totalAttendees.value += 1;
    intc_1 // 1
    +
    // contracts/proof-of-attendance.algo.ts:30
    // totalAttendees = GlobalState({ initialValue: Uint64(0) });
    bytec_0 // "totalAttendees"
    // contracts/proof-of-attendance.algo.ts:47
    // this.totalAttendees.value += 1;
    swap
    app_global_put
    // contracts/proof-of-attendance.algo.ts:49
    // const [_id, hasClaimed] = op.Box.get(Txn.sender.bytes);
    txn Sender
    box_get
    bury 1
    // contracts/proof-of-attendance.algo.ts:50
    // assert(!hasClaimed, "Already claimed POA");
    !
    assert // Already claimed POA
    // contracts/proof-of-attendance.algo.ts:52
    // op.Box.put(Txn.sender.bytes, op.itob(mintedAsset.id));
    txn Sender
    swap
    itob
    box_put
    retsub


// contracts/proof-of-attendance.algo.ts::ProofOfAttendance.confirmAttendanceWithBox() -> void:
confirmAttendanceWithBox:
    // contracts/proof-of-attendance.algo.ts:30
    // totalAttendees = GlobalState({ initialValue: Uint64(0) });
    intc_0 // 0
    bytec_0 // "totalAttendees"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/proof-of-attendance.algo.ts:26
    // maxAttendees = GlobalState({ initialValue: Uint64(30) });
    intc_0 // 0
    bytec_1 // "maxAttendees"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/proof-of-attendance.algo.ts:58
    // this.totalAttendees.value < this.maxAttendees.value,
    <
    // contracts/proof-of-attendance.algo.ts:57-60
    // assert(
    //   this.totalAttendees.value < this.maxAttendees.value,
    //   "Max attendees reached",
    // );
    assert // Max attendees reached
    // contracts/proof-of-attendance.algo.ts:62
    // const mintedAsset = this.mintPoa(Txn.sender);
    txn Sender
    callsub mintPoa
    // contracts/proof-of-attendance.algo.ts:30
    // totalAttendees = GlobalState({ initialValue: Uint64(0) });
    intc_0 // 0
    bytec_0 // "totalAttendees"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/proof-of-attendance.algo.ts:63
    // this.totalAttendees.value += 1;
    intc_1 // 1
    +
    // contracts/proof-of-attendance.algo.ts:30
    // totalAttendees = GlobalState({ initialValue: Uint64(0) });
    bytec_0 // "totalAttendees"
    // contracts/proof-of-attendance.algo.ts:63
    // this.totalAttendees.value += 1;
    swap
    app_global_put
    // contracts/proof-of-attendance.algo.ts:65
    // const box = Box<uint64>({ key: Txn.sender.bytes });
    txn Sender
    // contracts/proof-of-attendance.algo.ts:66
    // const hasClaimed = box.exists;
    dup
    box_len
    bury 1
    // contracts/proof-of-attendance.algo.ts:67
    // assert(!hasClaimed, "Already claimed POA");
    !
    assert // Already claimed POA
    // contracts/proof-of-attendance.algo.ts:69
    // box.value = mintedAsset.id;
    swap
    itob
    box_put
    retsub


// contracts/proof-of-attendance.algo.ts::ProofOfAttendance.confirmAttendanceWithBoxRef() -> void:
confirmAttendanceWithBoxRef:
    // contracts/proof-of-attendance.algo.ts:30
    // totalAttendees = GlobalState({ initialValue: Uint64(0) });
    intc_0 // 0
    bytec_0 // "totalAttendees"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/proof-of-attendance.algo.ts:26
    // maxAttendees = GlobalState({ initialValue: Uint64(30) });
    intc_0 // 0
    bytec_1 // "maxAttendees"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/proof-of-attendance.algo.ts:75
    // this.totalAttendees.value < this.maxAttendees.value,
    <
    // contracts/proof-of-attendance.algo.ts:74-77
    // assert(
    //   this.totalAttendees.value < this.maxAttendees.value,
    //   "Max attendees reached",
    // );
    assert // Max attendees reached
    // contracts/proof-of-attendance.algo.ts:79
    // const mintedAsset = this.mintPoa(Txn.sender);
    txn Sender
    callsub mintPoa
    // contracts/proof-of-attendance.algo.ts:30
    // totalAttendees = GlobalState({ initialValue: Uint64(0) });
    intc_0 // 0
    bytec_0 // "totalAttendees"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/proof-of-attendance.algo.ts:80
    // this.totalAttendees.value += 1;
    intc_1 // 1
    +
    // contracts/proof-of-attendance.algo.ts:30
    // totalAttendees = GlobalState({ initialValue: Uint64(0) });
    bytec_0 // "totalAttendees"
    // contracts/proof-of-attendance.algo.ts:80
    // this.totalAttendees.value += 1;
    swap
    app_global_put
    // contracts/proof-of-attendance.algo.ts:82
    // const boxRef = BoxRef({ key: Txn.sender.bytes });
    txn Sender
    // contracts/proof-of-attendance.algo.ts:83
    // const hasClaimed = boxRef.exists;
    dup
    box_len
    bury 1
    // contracts/proof-of-attendance.algo.ts:84
    // assert(!hasClaimed, "Already claimed POA");
    !
    assert // Already claimed POA
    // contracts/proof-of-attendance.algo.ts:86
    // boxRef.put(op.itob(mintedAsset.id));
    swap
    itob
    box_put
    retsub


// contracts/proof-of-attendance.algo.ts::ProofOfAttendance.confirmAttendanceWithBoxMap() -> void:
confirmAttendanceWithBoxMap:
    // contracts/proof-of-attendance.algo.ts:30
    // totalAttendees = GlobalState({ initialValue: Uint64(0) });
    intc_0 // 0
    bytec_0 // "totalAttendees"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/proof-of-attendance.algo.ts:26
    // maxAttendees = GlobalState({ initialValue: Uint64(30) });
    intc_0 // 0
    bytec_1 // "maxAttendees"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/proof-of-attendance.algo.ts:92
    // this.totalAttendees.value < this.maxAttendees.value,
    <
    // contracts/proof-of-attendance.algo.ts:91-94
    // assert(
    //   this.totalAttendees.value < this.maxAttendees.value,
    //   "Max attendees reached",
    // );
    assert // Max attendees reached
    // contracts/proof-of-attendance.algo.ts:96
    // const mintedAsset = this.mintPoa(Txn.sender);
    txn Sender
    callsub mintPoa
    // contracts/proof-of-attendance.algo.ts:30
    // totalAttendees = GlobalState({ initialValue: Uint64(0) });
    intc_0 // 0
    bytec_0 // "totalAttendees"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/proof-of-attendance.algo.ts:97
    // this.totalAttendees.value += 1;
    intc_1 // 1
    +
    // contracts/proof-of-attendance.algo.ts:30
    // totalAttendees = GlobalState({ initialValue: Uint64(0) });
    bytec_0 // "totalAttendees"
    // contracts/proof-of-attendance.algo.ts:97
    // this.totalAttendees.value += 1;
    swap
    app_global_put
    // contracts/proof-of-attendance.algo.ts:31
    // boxMap = BoxMap<bytes, uint64>({ keyPrefix: "boxMap" });
    bytec_3 // "boxMap"
    // contracts/proof-of-attendance.algo.ts:99
    // const hasClaimed = this.boxMap(Txn.sender.bytes).exists;
    txn Sender
    // contracts/proof-of-attendance.algo.ts:31
    // boxMap = BoxMap<bytes, uint64>({ keyPrefix: "boxMap" });
    concat
    // contracts/proof-of-attendance.algo.ts:99
    // const hasClaimed = this.boxMap(Txn.sender.bytes).exists;
    box_len
    bury 1
    // contracts/proof-of-attendance.algo.ts:100
    // assert(!hasClaimed, "Already claimed POA");
    !
    assert // Already claimed POA
    // contracts/proof-of-attendance.algo.ts:31
    // boxMap = BoxMap<bytes, uint64>({ keyPrefix: "boxMap" });
    bytec_3 // "boxMap"
    // contracts/proof-of-attendance.algo.ts:102
    // this.boxMap(Txn.sender.bytes).value = mintedAsset.id;
    txn Sender
    // contracts/proof-of-attendance.algo.ts:31
    // boxMap = BoxMap<bytes, uint64>({ keyPrefix: "boxMap" });
    concat
    // contracts/proof-of-attendance.algo.ts:102
    // this.boxMap(Txn.sender.bytes).value = mintedAsset.id;
    swap
    itob
    box_put
    retsub


// contracts/proof-of-attendance.algo.ts::ProofOfAttendance.getPoaId() -> uint64:
getPoaId:
    // contracts/proof-of-attendance.algo.ts:106
    // const [poaId, exists] = op.Box.get(Txn.sender.bytes);
    txn Sender
    box_get
    // contracts/proof-of-attendance.algo.ts:107
    // assert(exists, "POA not found");
    assert // POA not found
    // contracts/proof-of-attendance.algo.ts:108
    // return op.btoi(poaId);
    btoi
    retsub


// contracts/proof-of-attendance.algo.ts::ProofOfAttendance.getPoaIdWithBox() -> uint64:
getPoaIdWithBox:
    // contracts/proof-of-attendance.algo.ts:113
    // const box = Box<uint64>({ key: Txn.sender.bytes });
    txn Sender
    // contracts/proof-of-attendance.algo.ts:114
    // const [poaId, exists] = box.maybe();
    box_get
    swap
    btoi
    // contracts/proof-of-attendance.algo.ts:115
    // assert(exists, "POA not found");
    swap
    assert // POA not found
    // contracts/proof-of-attendance.algo.ts:116
    // return poaId;
    retsub


// contracts/proof-of-attendance.algo.ts::ProofOfAttendance.getPoaIdWithBoxRef() -> uint64:
getPoaIdWithBoxRef:
    // contracts/proof-of-attendance.algo.ts:121
    // const boxRef = BoxRef({ key: Txn.sender.bytes });
    txn Sender
    // contracts/proof-of-attendance.algo.ts:122
    // const [poaId, exists] = boxRef.maybe();
    box_get
    // contracts/proof-of-attendance.algo.ts:123
    // assert(exists, "POA not found");
    assert // POA not found
    // contracts/proof-of-attendance.algo.ts:124
    // return op.btoi(poaId);
    btoi
    retsub


// contracts/proof-of-attendance.algo.ts::ProofOfAttendance.getPoaIdWithBoxMap() -> uint64:
getPoaIdWithBoxMap:
    // contracts/proof-of-attendance.algo.ts:31
    // boxMap = BoxMap<bytes, uint64>({ keyPrefix: "boxMap" });
    bytec_3 // "boxMap"
    // contracts/proof-of-attendance.algo.ts:129
    // const [poaId, exists] = this.boxMap(Txn.sender.bytes).maybe();
    txn Sender
    // contracts/proof-of-attendance.algo.ts:31
    // boxMap = BoxMap<bytes, uint64>({ keyPrefix: "boxMap" });
    concat
    // contracts/proof-of-attendance.algo.ts:129
    // const [poaId, exists] = this.boxMap(Txn.sender.bytes).maybe();
    box_get
    swap
    btoi
    // contracts/proof-of-attendance.algo.ts:130
    // assert(exists, "POA not found");
    swap
    assert // POA not found
    // contracts/proof-of-attendance.algo.ts:131
    // return poaId;
    retsub


// contracts/proof-of-attendance.algo.ts::ProofOfAttendance.claimPoa(optInTxn: uint64) -> void:
claimPoa:
    // contracts/proof-of-attendance.algo.ts:134-135
    // @arc4.abimethod()
    // claimPoa(optInTxn: gtxn.AssetTransferTxn) {
    proto 1 0
    intc_0 // 0
    // contracts/proof-of-attendance.algo.ts:136
    // const [poaId, exists] = op.Box.get(Txn.sender.bytes);
    txn Sender
    box_get
    // contracts/proof-of-attendance.algo.ts:137
    // assert(exists, "POA not found, attendance validation failed!");
    assert // POA not found, attendance validation failed!
    // contracts/proof-of-attendance.algo.ts:138
    // assert(optInTxn.xferAsset.id === op.btoi(poaId), "POA ID mismatch");
    frame_dig -1
    gtxns XferAsset
    dup
    uncover 2
    btoi
    ==
    assert // POA ID mismatch
    // contracts/proof-of-attendance.algo.ts:139
    // assert(optInTxn.fee === 0, "We got you covered for free!");
    frame_dig -1
    gtxns Fee
    !
    assert // We got you covered for free!
    // contracts/proof-of-attendance.algo.ts:140
    // assert(optInTxn.assetAmount === 0);
    frame_dig -1
    gtxns AssetAmount
    !
    assert
    // contracts/proof-of-attendance.algo.ts:142
    // optInTxn.sender === optInTxn.assetReceiver &&
    frame_dig -1
    gtxns Sender
    frame_dig -1
    gtxns AssetReceiver
    dup
    cover 2
    ==
    // contracts/proof-of-attendance.algo.ts:142-143
    // optInTxn.sender === optInTxn.assetReceiver &&
    //   optInTxn.assetReceiver === Txn.sender,
    bz claimPoa_bool_false@3
    // contracts/proof-of-attendance.algo.ts:143
    // optInTxn.assetReceiver === Txn.sender,
    frame_dig 2
    txn Sender
    ==
    // contracts/proof-of-attendance.algo.ts:142-143
    // optInTxn.sender === optInTxn.assetReceiver &&
    //   optInTxn.assetReceiver === Txn.sender,
    bz claimPoa_bool_false@3
    intc_1 // 1

claimPoa_bool_merge@4:
    // contracts/proof-of-attendance.algo.ts:141-145
    // assert(
    //   optInTxn.sender === optInTxn.assetReceiver &&
    //     optInTxn.assetReceiver === Txn.sender,
    //   "Opt-in transaction sender and receiver must be the same",
    // );
    assert // Opt-in transaction sender and receiver must be the same
    // contracts/proof-of-attendance.algo.ts:147
    // optInTxn.assetCloseTo === optInTxn.rekeyTo &&
    frame_dig -1
    gtxns AssetCloseTo
    frame_dig -1
    gtxns RekeyTo
    dup
    frame_bury 0
    ==
    // contracts/proof-of-attendance.algo.ts:147-148
    // optInTxn.assetCloseTo === optInTxn.rekeyTo &&
    //   optInTxn.rekeyTo === Global.zeroAddress,
    bz claimPoa_bool_false@7
    // contracts/proof-of-attendance.algo.ts:148
    // optInTxn.rekeyTo === Global.zeroAddress,
    frame_dig 0
    global ZeroAddress
    ==
    // contracts/proof-of-attendance.algo.ts:147-148
    // optInTxn.assetCloseTo === optInTxn.rekeyTo &&
    //   optInTxn.rekeyTo === Global.zeroAddress,
    bz claimPoa_bool_false@7
    intc_1 // 1

claimPoa_bool_merge@8:
    // contracts/proof-of-attendance.algo.ts:146-150
    // assert(
    //   optInTxn.assetCloseTo === optInTxn.rekeyTo &&
    //     optInTxn.rekeyTo === Global.zeroAddress,
    //   "Opt-in transaction close to must be zero address",
    // );
    assert // Opt-in transaction close to must be zero address
    // contracts/proof-of-attendance.algo.ts:152
    // this.sendPoa(Txn.sender, optInTxn.xferAsset);
    txn Sender
    frame_dig 1
    callsub sendPoa
    retsub

claimPoa_bool_false@7:
    intc_0 // 0
    b claimPoa_bool_merge@8

claimPoa_bool_false@3:
    intc_0 // 0
    b claimPoa_bool_merge@4


// contracts/proof-of-attendance.algo.ts::ProofOfAttendance.claimPoaWithBox(optInTxn: uint64) -> void:
claimPoaWithBox:
    // contracts/proof-of-attendance.algo.ts:155-156
    // @arc4.abimethod()
    // claimPoaWithBox(optInTxn: gtxn.AssetTransferTxn) {
    proto 1 0
    intc_0 // 0
    // contracts/proof-of-attendance.algo.ts:157
    // const box = Box<uint64>({ key: Txn.sender.bytes });
    txn Sender
    // contracts/proof-of-attendance.algo.ts:158
    // const [poaId, exists] = box.maybe();
    box_get
    swap
    btoi
    // contracts/proof-of-attendance.algo.ts:159
    // assert(exists, "POA not found, attendance validation failed!");
    swap
    assert // POA not found, attendance validation failed!
    // contracts/proof-of-attendance.algo.ts:160
    // assert(optInTxn.xferAsset.id === poaId, "POA ID mismatch");
    frame_dig -1
    gtxns XferAsset
    dup
    uncover 2
    ==
    assert // POA ID mismatch
    // contracts/proof-of-attendance.algo.ts:161
    // assert(optInTxn.fee === 0, "We got you covered for free!");
    frame_dig -1
    gtxns Fee
    !
    assert // We got you covered for free!
    // contracts/proof-of-attendance.algo.ts:162
    // assert(optInTxn.assetAmount === 0);
    frame_dig -1
    gtxns AssetAmount
    !
    assert
    // contracts/proof-of-attendance.algo.ts:164
    // optInTxn.sender === optInTxn.assetReceiver &&
    frame_dig -1
    gtxns Sender
    frame_dig -1
    gtxns AssetReceiver
    dup
    cover 2
    ==
    // contracts/proof-of-attendance.algo.ts:164-165
    // optInTxn.sender === optInTxn.assetReceiver &&
    //   optInTxn.assetReceiver === Txn.sender,
    bz claimPoaWithBox_bool_false@3
    // contracts/proof-of-attendance.algo.ts:165
    // optInTxn.assetReceiver === Txn.sender,
    frame_dig 2
    txn Sender
    ==
    // contracts/proof-of-attendance.algo.ts:164-165
    // optInTxn.sender === optInTxn.assetReceiver &&
    //   optInTxn.assetReceiver === Txn.sender,
    bz claimPoaWithBox_bool_false@3
    intc_1 // 1

claimPoaWithBox_bool_merge@4:
    // contracts/proof-of-attendance.algo.ts:163-167
    // assert(
    //   optInTxn.sender === optInTxn.assetReceiver &&
    //     optInTxn.assetReceiver === Txn.sender,
    //   "Opt-in transaction sender and receiver must be the same",
    // );
    assert // Opt-in transaction sender and receiver must be the same
    // contracts/proof-of-attendance.algo.ts:169
    // optInTxn.assetCloseTo === optInTxn.rekeyTo &&
    frame_dig -1
    gtxns AssetCloseTo
    frame_dig -1
    gtxns RekeyTo
    dup
    frame_bury 0
    ==
    // contracts/proof-of-attendance.algo.ts:169-170
    // optInTxn.assetCloseTo === optInTxn.rekeyTo &&
    //   optInTxn.rekeyTo === Global.zeroAddress,
    bz claimPoaWithBox_bool_false@7
    // contracts/proof-of-attendance.algo.ts:170
    // optInTxn.rekeyTo === Global.zeroAddress,
    frame_dig 0
    global ZeroAddress
    ==
    // contracts/proof-of-attendance.algo.ts:169-170
    // optInTxn.assetCloseTo === optInTxn.rekeyTo &&
    //   optInTxn.rekeyTo === Global.zeroAddress,
    bz claimPoaWithBox_bool_false@7
    intc_1 // 1

claimPoaWithBox_bool_merge@8:
    // contracts/proof-of-attendance.algo.ts:168-172
    // assert(
    //   optInTxn.assetCloseTo === optInTxn.rekeyTo &&
    //     optInTxn.rekeyTo === Global.zeroAddress,
    //   "Opt-in transaction close to must be zero address",
    // );
    assert // Opt-in transaction close to must be zero address
    // contracts/proof-of-attendance.algo.ts:174
    // this.sendPoa(Txn.sender, optInTxn.xferAsset);
    txn Sender
    frame_dig 1
    callsub sendPoa
    retsub

claimPoaWithBox_bool_false@7:
    intc_0 // 0
    b claimPoaWithBox_bool_merge@8

claimPoaWithBox_bool_false@3:
    intc_0 // 0
    b claimPoaWithBox_bool_merge@4


// contracts/proof-of-attendance.algo.ts::ProofOfAttendance.claimPoaWithBoxRef(optInTxn: uint64) -> void:
claimPoaWithBoxRef:
    // contracts/proof-of-attendance.algo.ts:177-178
    // @arc4.abimethod()
    // claimPoaWithBoxRef(optInTxn: gtxn.AssetTransferTxn) {
    proto 1 0
    intc_0 // 0
    // contracts/proof-of-attendance.algo.ts:179
    // const boxRef = BoxRef({ key: Txn.sender.bytes });
    txn Sender
    // contracts/proof-of-attendance.algo.ts:180
    // const [poaId, exists] = boxRef.maybe();
    box_get
    // contracts/proof-of-attendance.algo.ts:181
    // assert(exists, "POA not found, attendance validation failed!");
    assert // POA not found, attendance validation failed!
    // contracts/proof-of-attendance.algo.ts:182
    // assert(optInTxn.xferAsset.id === op.btoi(poaId), "POA ID mismatch");
    frame_dig -1
    gtxns XferAsset
    dup
    uncover 2
    btoi
    ==
    assert // POA ID mismatch
    // contracts/proof-of-attendance.algo.ts:183
    // assert(optInTxn.fee === 0, "We got you covered for free!");
    frame_dig -1
    gtxns Fee
    !
    assert // We got you covered for free!
    // contracts/proof-of-attendance.algo.ts:184
    // assert(optInTxn.assetAmount === 0);
    frame_dig -1
    gtxns AssetAmount
    !
    assert
    // contracts/proof-of-attendance.algo.ts:186
    // optInTxn.sender === optInTxn.assetReceiver &&
    frame_dig -1
    gtxns Sender
    frame_dig -1
    gtxns AssetReceiver
    dup
    cover 2
    ==
    // contracts/proof-of-attendance.algo.ts:186-187
    // optInTxn.sender === optInTxn.assetReceiver &&
    //   optInTxn.assetReceiver === Txn.sender,
    bz claimPoaWithBoxRef_bool_false@3
    // contracts/proof-of-attendance.algo.ts:187
    // optInTxn.assetReceiver === Txn.sender,
    frame_dig 2
    txn Sender
    ==
    // contracts/proof-of-attendance.algo.ts:186-187
    // optInTxn.sender === optInTxn.assetReceiver &&
    //   optInTxn.assetReceiver === Txn.sender,
    bz claimPoaWithBoxRef_bool_false@3
    intc_1 // 1

claimPoaWithBoxRef_bool_merge@4:
    // contracts/proof-of-attendance.algo.ts:185-189
    // assert(
    //   optInTxn.sender === optInTxn.assetReceiver &&
    //     optInTxn.assetReceiver === Txn.sender,
    //   "Opt-in transaction sender and receiver must be the same",
    // );
    assert // Opt-in transaction sender and receiver must be the same
    // contracts/proof-of-attendance.algo.ts:191
    // optInTxn.assetCloseTo === optInTxn.rekeyTo &&
    frame_dig -1
    gtxns AssetCloseTo
    frame_dig -1
    gtxns RekeyTo
    dup
    frame_bury 0
    ==
    // contracts/proof-of-attendance.algo.ts:191-192
    // optInTxn.assetCloseTo === optInTxn.rekeyTo &&
    //   optInTxn.rekeyTo === Global.zeroAddress,
    bz claimPoaWithBoxRef_bool_false@7
    // contracts/proof-of-attendance.algo.ts:192
    // optInTxn.rekeyTo === Global.zeroAddress,
    frame_dig 0
    global ZeroAddress
    ==
    // contracts/proof-of-attendance.algo.ts:191-192
    // optInTxn.assetCloseTo === optInTxn.rekeyTo &&
    //   optInTxn.rekeyTo === Global.zeroAddress,
    bz claimPoaWithBoxRef_bool_false@7
    intc_1 // 1

claimPoaWithBoxRef_bool_merge@8:
    // contracts/proof-of-attendance.algo.ts:190-194
    // assert(
    //   optInTxn.assetCloseTo === optInTxn.rekeyTo &&
    //     optInTxn.rekeyTo === Global.zeroAddress,
    //   "Opt-in transaction close to must be zero address",
    // );
    assert // Opt-in transaction close to must be zero address
    // contracts/proof-of-attendance.algo.ts:196
    // this.sendPoa(Txn.sender, optInTxn.xferAsset);
    txn Sender
    frame_dig 1
    callsub sendPoa
    retsub

claimPoaWithBoxRef_bool_false@7:
    intc_0 // 0
    b claimPoaWithBoxRef_bool_merge@8

claimPoaWithBoxRef_bool_false@3:
    intc_0 // 0
    b claimPoaWithBoxRef_bool_merge@4


// contracts/proof-of-attendance.algo.ts::ProofOfAttendance.claimPoaWithBoxMap(optInTxn: uint64) -> void:
claimPoaWithBoxMap:
    // contracts/proof-of-attendance.algo.ts:199-200
    // @arc4.abimethod()
    // claimPoaWithBoxMap(optInTxn: gtxn.AssetTransferTxn) {
    proto 1 0
    intc_0 // 0
    // contracts/proof-of-attendance.algo.ts:31
    // boxMap = BoxMap<bytes, uint64>({ keyPrefix: "boxMap" });
    bytec_3 // "boxMap"
    // contracts/proof-of-attendance.algo.ts:201
    // const [poaId, exists] = this.boxMap(Txn.sender.bytes).maybe();
    txn Sender
    // contracts/proof-of-attendance.algo.ts:31
    // boxMap = BoxMap<bytes, uint64>({ keyPrefix: "boxMap" });
    concat
    // contracts/proof-of-attendance.algo.ts:201
    // const [poaId, exists] = this.boxMap(Txn.sender.bytes).maybe();
    box_get
    swap
    btoi
    // contracts/proof-of-attendance.algo.ts:202
    // assert(exists, "POA not found, attendance validation failed!");
    swap
    assert // POA not found, attendance validation failed!
    // contracts/proof-of-attendance.algo.ts:203
    // assert(optInTxn.xferAsset.id === poaId, "POA ID mismatch");
    frame_dig -1
    gtxns XferAsset
    dup
    uncover 2
    ==
    assert // POA ID mismatch
    // contracts/proof-of-attendance.algo.ts:204
    // assert(optInTxn.fee === 0, "We got you covered for free!");
    frame_dig -1
    gtxns Fee
    !
    assert // We got you covered for free!
    // contracts/proof-of-attendance.algo.ts:205
    // assert(optInTxn.assetAmount === 0);
    frame_dig -1
    gtxns AssetAmount
    !
    assert
    // contracts/proof-of-attendance.algo.ts:207
    // optInTxn.sender === optInTxn.assetReceiver &&
    frame_dig -1
    gtxns Sender
    frame_dig -1
    gtxns AssetReceiver
    dup
    cover 2
    ==
    // contracts/proof-of-attendance.algo.ts:207-208
    // optInTxn.sender === optInTxn.assetReceiver &&
    //   optInTxn.assetReceiver === Txn.sender,
    bz claimPoaWithBoxMap_bool_false@3
    // contracts/proof-of-attendance.algo.ts:208
    // optInTxn.assetReceiver === Txn.sender,
    frame_dig 2
    txn Sender
    ==
    // contracts/proof-of-attendance.algo.ts:207-208
    // optInTxn.sender === optInTxn.assetReceiver &&
    //   optInTxn.assetReceiver === Txn.sender,
    bz claimPoaWithBoxMap_bool_false@3
    intc_1 // 1

claimPoaWithBoxMap_bool_merge@4:
    // contracts/proof-of-attendance.algo.ts:206-210
    // assert(
    //   optInTxn.sender === optInTxn.assetReceiver &&
    //     optInTxn.assetReceiver === Txn.sender,
    //   "Opt-in transaction sender and receiver must be the same",
    // );
    assert // Opt-in transaction sender and receiver must be the same
    // contracts/proof-of-attendance.algo.ts:212
    // optInTxn.assetCloseTo === optInTxn.rekeyTo &&
    frame_dig -1
    gtxns AssetCloseTo
    frame_dig -1
    gtxns RekeyTo
    dup
    frame_bury 0
    ==
    // contracts/proof-of-attendance.algo.ts:212-213
    // optInTxn.assetCloseTo === optInTxn.rekeyTo &&
    //   optInTxn.rekeyTo === Global.zeroAddress,
    bz claimPoaWithBoxMap_bool_false@7
    // contracts/proof-of-attendance.algo.ts:213
    // optInTxn.rekeyTo === Global.zeroAddress,
    frame_dig 0
    global ZeroAddress
    ==
    // contracts/proof-of-attendance.algo.ts:212-213
    // optInTxn.assetCloseTo === optInTxn.rekeyTo &&
    //   optInTxn.rekeyTo === Global.zeroAddress,
    bz claimPoaWithBoxMap_bool_false@7
    intc_1 // 1

claimPoaWithBoxMap_bool_merge@8:
    // contracts/proof-of-attendance.algo.ts:211-215
    // assert(
    //   optInTxn.assetCloseTo === optInTxn.rekeyTo &&
    //     optInTxn.rekeyTo === Global.zeroAddress,
    //   "Opt-in transaction close to must be zero address",
    // );
    assert // Opt-in transaction close to must be zero address
    // contracts/proof-of-attendance.algo.ts:217
    // this.sendPoa(Txn.sender, optInTxn.xferAsset);
    txn Sender
    frame_dig 1
    callsub sendPoa
    retsub

claimPoaWithBoxMap_bool_false@7:
    intc_0 // 0
    b claimPoaWithBoxMap_bool_merge@8

claimPoaWithBoxMap_bool_false@3:
    intc_0 // 0
    b claimPoaWithBoxMap_bool_merge@4


// contracts/proof-of-attendance.algo.ts::ProofOfAttendance.mintPoa(claimer: bytes) -> uint64:
mintPoa:
    // contracts/proof-of-attendance.algo.ts:220
    // private mintPoa(claimer: Account): Asset {
    proto 1 1

mintPoa_while_top@3:
    pushint 10010 // 10010
    global OpcodeBudget
    >
    bz mintPoa_after_while@8
    itxn_begin
    pushint 6 // appl
    itxn_field TypeEnum
    pushint 5 // DeleteApplication
    itxn_field OnCompletion
    bytec 5 // 0x068101
    itxn_field ApprovalProgram
    bytec 5 // 0x068101
    itxn_field ClearStateProgram
    global MinTxnFee
    itxn_field Fee
    itxn_submit
    b mintPoa_while_top@3

mintPoa_after_while@8:
    // contracts/proof-of-attendance.algo.ts:30
    // totalAttendees = GlobalState({ initialValue: Uint64(0) });
    intc_0 // 0
    bytec_0 // "totalAttendees"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/proof-of-attendance.algo.ts:223
    // op.itob(this.totalAttendees.value),
    itob
    // contracts/proof-of-attendance.algo.ts:222
    // const assetName = Bytes("AlgoKit POA #").concat(
    pushbytes "AlgoKit POA #"
    // contracts/proof-of-attendance.algo.ts:222-224
    // const assetName = Bytes("AlgoKit POA #").concat(
    //   op.itob(this.totalAttendees.value),
    // );
    swap
    concat
    // contracts/proof-of-attendance.algo.ts:225-234
    // return itxn
    //   .assetConfig({
    //     assetName: assetName,
    //     unitName: "POA",
    //     total: 1,
    //     decimals: 0,
    //     url: this.assetUrl.value,
    //     manager: claimer,
    //   })
    //   .submit().createdAsset;
    itxn_begin
    // contracts/proof-of-attendance.algo.ts:27
    // assetUrl = GlobalState({
    intc_0 // 0
    bytec 4 // "assetUrl"
    app_global_get_ex
    assert // check GlobalState exists
    frame_dig -1
    itxn_field ConfigAssetManager
    itxn_field ConfigAssetURL
    // contracts/proof-of-attendance.algo.ts:230
    // decimals: 0,
    intc_0 // 0
    itxn_field ConfigAssetDecimals
    // contracts/proof-of-attendance.algo.ts:229
    // total: 1,
    intc_1 // 1
    itxn_field ConfigAssetTotal
    // contracts/proof-of-attendance.algo.ts:228
    // unitName: "POA",
    pushbytes "POA"
    itxn_field ConfigAssetUnitName
    itxn_field ConfigAssetName
    // contracts/proof-of-attendance.algo.ts:225-233
    // return itxn
    //   .assetConfig({
    //     assetName: assetName,
    //     unitName: "POA",
    //     total: 1,
    //     decimals: 0,
    //     url: this.assetUrl.value,
    //     manager: claimer,
    //   })
    pushint 3 // 3
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // contracts/proof-of-attendance.algo.ts:225-234
    // return itxn
    //   .assetConfig({
    //     assetName: assetName,
    //     unitName: "POA",
    //     total: 1,
    //     decimals: 0,
    //     url: this.assetUrl.value,
    //     manager: claimer,
    //   })
    //   .submit().createdAsset;
    itxn_submit
    // contracts/proof-of-attendance.algo.ts:234
    // .submit().createdAsset;
    itxn CreatedAssetID
    // contracts/proof-of-attendance.algo.ts:225-234
    // return itxn
    //   .assetConfig({
    //     assetName: assetName,
    //     unitName: "POA",
    //     total: 1,
    //     decimals: 0,
    //     url: this.assetUrl.value,
    //     manager: claimer,
    //   })
    //   .submit().createdAsset;
    retsub


// contracts/proof-of-attendance.algo.ts::ProofOfAttendance.sendPoa(receiver: bytes, asset: uint64) -> void:
sendPoa:
    // contracts/proof-of-attendance.algo.ts:237
    // private sendPoa(receiver: Account, asset: Asset) {
    proto 2 0
    // contracts/proof-of-attendance.algo.ts:238-245
    // itxn
    //   .assetTransfer({
    //     xferAsset: asset,
    //     sender: Global.currentApplicationAddress,
    //     assetReceiver: receiver,
    //     assetAmount: 1,
    //   })
    //   .submit();
    itxn_begin
    // contracts/proof-of-attendance.algo.ts:241
    // sender: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // contracts/proof-of-attendance.algo.ts:243
    // assetAmount: 1,
    intc_1 // 1
    itxn_field AssetAmount
    frame_dig -2
    itxn_field AssetReceiver
    itxn_field Sender
    frame_dig -1
    itxn_field XferAsset
    // contracts/proof-of-attendance.algo.ts:238-244
    // itxn
    //   .assetTransfer({
    //     xferAsset: asset,
    //     sender: Global.currentApplicationAddress,
    //     assetReceiver: receiver,
    //     assetAmount: 1,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // contracts/proof-of-attendance.algo.ts:238-245
    // itxn
    //   .assetTransfer({
    //     xferAsset: asset,
    //     sender: Global.currentApplicationAddress,
    //     assetReceiver: receiver,
    //     assetAmount: 1,
    //   })
    //   .submit();
    itxn_submit
    retsub
